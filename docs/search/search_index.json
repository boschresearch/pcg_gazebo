{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pcg_gazebo : A Python package for rapid-prototyping and scripting of simulations for Gazebo \u00b6 The pcg_gazebo Python package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Visit the documentation page for more information. Purpose of the project \u00b6 This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262). Installation \u00b6 Using pip \u00b6 You can install the pcg-gazebo package using pip as follows pip install pcg-gazebo you still might need to install some extra dependencies that cannot be handled by pip as sudo apt install libspatialindex-dev pybind11-dev libgeos-dev The default installation does not include rospy dependencies that are not available as a pip package. They have to be installed separately for certain submodules to work, such as pcg_gazebo.task_manager . From source \u00b6 First install some non-Python dependencies sudo apt install libspatialindex-dev pybind11-dev libgeos-dev Then clone the repository and install it using pip git clone https://github.com/boschresearch/pcg_gazebo.git cd pcg_gazebo pip install . Using the package with ROS and Gazebo \u00b6 Certain functionalities as the Gazebo proxy, task manager and model spawning are only available if rospy is installed. The lack of Gazebo and rospy only restricts functionalities related to interaction with the simulation in runtime and the creation of ROS-related tasks. At the moment, ROS 2 is not supported for this purpose. To install ROS melodic , follow these installation instructions and install ros-melodic-desktop-full or separately install Gazebo and its ROS bindings as sudo apt install gazebo9 libgazebo9-dev ros-melodic-gazebo-* License \u00b6 Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses .","title":"Home"},{"location":"#pcg_gazebo-a-python-package-for-rapid-prototyping-and-scripting-of-simulations-for-gazebo","text":"The pcg_gazebo Python package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Visit the documentation page for more information.","title":"pcg_gazebo: A Python package for rapid-prototyping and scripting of simulations for Gazebo"},{"location":"#purpose-of-the-project","text":"This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262).","title":"Purpose of the project"},{"location":"#installation","text":"","title":"Installation"},{"location":"#using-pip","text":"You can install the pcg-gazebo package using pip as follows pip install pcg-gazebo you still might need to install some extra dependencies that cannot be handled by pip as sudo apt install libspatialindex-dev pybind11-dev libgeos-dev The default installation does not include rospy dependencies that are not available as a pip package. They have to be installed separately for certain submodules to work, such as pcg_gazebo.task_manager .","title":"Using pip"},{"location":"#from-source","text":"First install some non-Python dependencies sudo apt install libspatialindex-dev pybind11-dev libgeos-dev Then clone the repository and install it using pip git clone https://github.com/boschresearch/pcg_gazebo.git cd pcg_gazebo pip install .","title":"From source"},{"location":"#using-the-package-with-ros-and-gazebo","text":"Certain functionalities as the Gazebo proxy, task manager and model spawning are only available if rospy is installed. The lack of Gazebo and rospy only restricts functionalities related to interaction with the simulation in runtime and the creation of ROS-related tasks. At the moment, ROS 2 is not supported for this purpose. To install ROS melodic , follow these installation instructions and install ros-melodic-desktop-full or separately install Gazebo and its ROS bindings as sudo apt install gazebo9 libgazebo9-dev ros-melodic-gazebo-*","title":"Using the package with ROS and Gazebo"},{"location":"#license","text":"Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses .","title":"License"},{"location":"examples/","text":"This folder contains a number of examples demonstrating the features of the pcg_gazebo package. To run the Jupyter notebooks, be sure to install it as pip install jupyterlab Model generation \u00b6 Creating full Gazebo models in Python \u00b6 In the example on creating Gazebo models in Python , it is demonstrated how to use the tools from the simulation module in order to create simulation entities and can be spawned directly into Gazebo. Model group generator \u00b6 In the model group generator example notebook , it is demonstrated how to create a model group abstraction in which the model's parameters are re-calculated each time an instance of the model group is created. This allows using a single representation of the model group generator as an asset and generating its variations as an instance is created. Model factory \u00b6 In the model factory example notebook , it is demonstrated how to use the creators module to create parametrized simulation models and spawn them in Gazebo. Generating models from a YAML configuration file \u00b6 This examples shows how to define a simulation model as a YAML file and generate static Gazebo models to be stored in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_factory_config.sh CONFIG_NAME where CONFIG_NAME refers to the name of one the files (without the .yaml extension) in the examples/model_factory folder. For example, by running ./gen_model_from_factory_config.sh box_dynamic_model will generate a box model with mass and moments of inertia and store it in the folder $HOME/.pcg/models/pcg_box_dynamic , including model.config and model.sdf files. Some YAML files include a batch of model descriptions and therefore will produce multiple Gazebo models in the $HOME/.pcg/models folder. This example runs the chosen YAML file with the run_model_factory script, that feeds the data into the model factory functions found in the model factory module . To find out more about how to run the model factory from script, run run_model_factory -h To generate the model from the YAML file configuration and spawn it into Gazebo, first start Gazebo as roslaunch gazebo_ros empty_world.launch and then use the same CONFIG_NAME to run the script ./spawn_model_from_factory_config.sh CONFIG_NAME Generating models from template Jinja files \u00b6 This examples shows how generate an SDF file for a Gazebo model from a Jinja template and store static Gazebo models in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_template.sh TEMPLATE_NAME where TEMPLATE_NAME refers to the name of one the files (without the .yaml extension) in the examples/templates/models folder. For example, by running ./gen_model_from_template.sh pcg_bouncy_ball will generate single-link spherical model with the necessary settings to allow it to bounce when colliding with another object. The model is per default stored in the folder $HOME/.pcg/models/pcg_bouncy_ball , including model.config and model.sdf files. To find out more about how to run the Jinja processor from script, run process_jinja_template -h This notebook also shows an example on how the kobuki robot (converted to a Jinja template to generate the robot description in SDF format ) is processed from its templates and imported as an SimulationModel object that can be edited and spawned into the simulation. World generation \u00b6 Dynamically generating worlds from YAML configuration file \u00b6 The pcg_gazebo package includes not only model creators but also engines that allow creating and placing objects in the world according to pre-defined policies and respecting certain constraints. The sample configurations that allow worlds to be dynamically created can be found in examples/world_generator/worlds and by running ./launch_pcg_world.sh WORLD_CONFIG_NAME WORLD_CONFIG_NAME being the name of the world configuration file (without the .yaml extension) in the examples/world_generator/worlds folder. The resulting world file will be stored in $HOME/.pcg/worlds folder. For example, by calling ./launch_pcg_world.sh bouncing_balls_ode generates an environment of 40 spheres placed randomly in the 3D world, all of them with the bounce settings enabled so that they will bounce against the ground and each other. Occupancy grid map generation \u00b6 Occupancy grid maps can be computed from single models, model groups or worlds using ray tracing. In this notebook it is demonstrated how a grid map can be plotted and stored from a generated world. Parsers \u00b6 Parsing xacro files \u00b6 This example it is shown how to import a xacro file that will be processed, rendered into an URDF file and imported as a SimulationModel object. List of Jupyter notebooks \u00b6 Simulation \u00b6 To run some of the notebooks below you may need to source your current ROS distribution and have Gazebo installed in your system since they will also run the simulation. To source ROS, use source /opt/ros/ $ROS_DISTRO /setup.bash # You can also replace $ROS_DISTRO by the distro you are using, e.g. melodic The installation instructions for Gazebo can be found here . Testing the model's surface collision properties Using the model factory Inspecting Gazebo models Creating models with Jupyter notebooks Stopping Gazebo with a simulation timeout Using model group generators Creating sensors Creating single-link models Stopping Gazebo with a process timeout Handling meshes Configuring the different physics engines Inspecting different formats of robot descriptions Handling Gazebo materials SDF parsers \u00b6 The examples for the sdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Importing SDF file Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <materials> elements Parsing <model> elements Parsing <physics> elements Parsing <plugin> elements Parsing <visual> elements Parsing <world> elements URDF parsers \u00b6 The examples for the urdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <robot> elements Parsing <visual> elements Occupancy grid generation \u00b6 Generating an occupancy grid map from a generated world Task manager \u00b6 Using the Gazebo proxy object Showcasing the process manager for simulation tasks Showcasing the setup of conditional stages for sequences of tasks","title":"Examples"},{"location":"examples/#model-generation","text":"","title":"Model generation"},{"location":"examples/#creating-full-gazebo-models-in-python","text":"In the example on creating Gazebo models in Python , it is demonstrated how to use the tools from the simulation module in order to create simulation entities and can be spawned directly into Gazebo.","title":"Creating full Gazebo models in Python"},{"location":"examples/#model-group-generator","text":"In the model group generator example notebook , it is demonstrated how to create a model group abstraction in which the model's parameters are re-calculated each time an instance of the model group is created. This allows using a single representation of the model group generator as an asset and generating its variations as an instance is created.","title":"Model group generator"},{"location":"examples/#model-factory","text":"In the model factory example notebook , it is demonstrated how to use the creators module to create parametrized simulation models and spawn them in Gazebo.","title":"Model factory"},{"location":"examples/#generating-models-from-a-yaml-configuration-file","text":"This examples shows how to define a simulation model as a YAML file and generate static Gazebo models to be stored in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_factory_config.sh CONFIG_NAME where CONFIG_NAME refers to the name of one the files (without the .yaml extension) in the examples/model_factory folder. For example, by running ./gen_model_from_factory_config.sh box_dynamic_model will generate a box model with mass and moments of inertia and store it in the folder $HOME/.pcg/models/pcg_box_dynamic , including model.config and model.sdf files. Some YAML files include a batch of model descriptions and therefore will produce multiple Gazebo models in the $HOME/.pcg/models folder. This example runs the chosen YAML file with the run_model_factory script, that feeds the data into the model factory functions found in the model factory module . To find out more about how to run the model factory from script, run run_model_factory -h To generate the model from the YAML file configuration and spawn it into Gazebo, first start Gazebo as roslaunch gazebo_ros empty_world.launch and then use the same CONFIG_NAME to run the script ./spawn_model_from_factory_config.sh CONFIG_NAME","title":"Generating models from a YAML configuration file"},{"location":"examples/#generating-models-from-template-jinja-files","text":"This examples shows how generate an SDF file for a Gazebo model from a Jinja template and store static Gazebo models in your local $HOME/.pcg/models folder. This example requires you to run the script in the examples folder ./gen_model_from_template.sh TEMPLATE_NAME where TEMPLATE_NAME refers to the name of one the files (without the .yaml extension) in the examples/templates/models folder. For example, by running ./gen_model_from_template.sh pcg_bouncy_ball will generate single-link spherical model with the necessary settings to allow it to bounce when colliding with another object. The model is per default stored in the folder $HOME/.pcg/models/pcg_bouncy_ball , including model.config and model.sdf files. To find out more about how to run the Jinja processor from script, run process_jinja_template -h This notebook also shows an example on how the kobuki robot (converted to a Jinja template to generate the robot description in SDF format ) is processed from its templates and imported as an SimulationModel object that can be edited and spawned into the simulation.","title":"Generating models from template Jinja files"},{"location":"examples/#world-generation","text":"","title":"World generation"},{"location":"examples/#dynamically-generating-worlds-from-yaml-configuration-file","text":"The pcg_gazebo package includes not only model creators but also engines that allow creating and placing objects in the world according to pre-defined policies and respecting certain constraints. The sample configurations that allow worlds to be dynamically created can be found in examples/world_generator/worlds and by running ./launch_pcg_world.sh WORLD_CONFIG_NAME WORLD_CONFIG_NAME being the name of the world configuration file (without the .yaml extension) in the examples/world_generator/worlds folder. The resulting world file will be stored in $HOME/.pcg/worlds folder. For example, by calling ./launch_pcg_world.sh bouncing_balls_ode generates an environment of 40 spheres placed randomly in the 3D world, all of them with the bounce settings enabled so that they will bounce against the ground and each other.","title":"Dynamically generating worlds from YAML configuration file"},{"location":"examples/#occupancy-grid-map-generation","text":"Occupancy grid maps can be computed from single models, model groups or worlds using ray tracing. In this notebook it is demonstrated how a grid map can be plotted and stored from a generated world.","title":"Occupancy grid map generation"},{"location":"examples/#parsers","text":"","title":"Parsers"},{"location":"examples/#parsing-xacro-files","text":"This example it is shown how to import a xacro file that will be processed, rendered into an URDF file and imported as a SimulationModel object.","title":"Parsing xacro files"},{"location":"examples/#list-of-jupyter-notebooks","text":"","title":"List of Jupyter notebooks"},{"location":"examples/#simulation","text":"To run some of the notebooks below you may need to source your current ROS distribution and have Gazebo installed in your system since they will also run the simulation. To source ROS, use source /opt/ros/ $ROS_DISTRO /setup.bash # You can also replace $ROS_DISTRO by the distro you are using, e.g. melodic The installation instructions for Gazebo can be found here . Testing the model's surface collision properties Using the model factory Inspecting Gazebo models Creating models with Jupyter notebooks Stopping Gazebo with a simulation timeout Using model group generators Creating sensors Creating single-link models Stopping Gazebo with a process timeout Handling meshes Configuring the different physics engines Inspecting different formats of robot descriptions Handling Gazebo materials","title":"Simulation"},{"location":"examples/#sdf-parsers","text":"The examples for the sdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Importing SDF file Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <materials> elements Parsing <model> elements Parsing <physics> elements Parsing <plugin> elements Parsing <visual> elements Parsing <world> elements","title":"SDF parsers"},{"location":"examples/#urdf-parsers","text":"The examples for the urdf parser is available as Jupyter notebooks. The list can be seen below. Parsing <collision> elements Parsing <geometry> elements Parsing <link> , <joint> and <sensor> elements Parsing <robot> elements Parsing <visual> elements","title":"URDF parsers"},{"location":"examples/#occupancy-grid-generation","text":"Generating an occupancy grid map from a generated world","title":"Occupancy grid generation"},{"location":"examples/#task-manager","text":"Using the Gazebo proxy object Showcasing the process manager for simulation tasks Showcasing the setup of conditional stages for sequences of tasks","title":"Task manager"},{"location":"install/","text":"Advanced installation \u00b6 The list of Python dependencies can be retrieved by cloning this package and running the setup.py script as follows: python setup.py --list-all The package requires some non-Python libraries that are not resolved using the usual Python installation. Running the following command installs the missing dependencies. sudo apt install libspatialindex-dev pybind11-dev libgeos-dev As a pip package \u00b6 pip install pcg-gazebo It is highly recommended to use Python 3.x. To install also dependencies necessary to run the pcg-gazebo package in a Jupyter notebook, run pip install pcg-gazebo [ all ] ROS \u00b6 The pcg-gazebo package is available as a ROS dependency that can be resolved by rosdep . It is necessary to add the following tag in the package.xml file of your ROS package as <exec_depend> python3-pcg-gazebo-pip </exec_depend> for Python 3.x, and <exec_depend> python-pcg-gazebo-pip </exec_depend> for Python 2.x.","title":"Advanced Installation"},{"location":"install/#advanced-installation","text":"The list of Python dependencies can be retrieved by cloning this package and running the setup.py script as follows: python setup.py --list-all The package requires some non-Python libraries that are not resolved using the usual Python installation. Running the following command installs the missing dependencies. sudo apt install libspatialindex-dev pybind11-dev libgeos-dev","title":"Advanced installation"},{"location":"install/#as-a-pip-package","text":"pip install pcg-gazebo It is highly recommended to use Python 3.x. To install also dependencies necessary to run the pcg-gazebo package in a Jupyter notebook, run pip install pcg-gazebo [ all ]","title":"As a pip package"},{"location":"install/#ros","text":"The pcg-gazebo package is available as a ROS dependency that can be resolved by rosdep . It is necessary to add the following tag in the package.xml file of your ROS package as <exec_depend> python3-pcg-gazebo-pip </exec_depend> for Python 3.x, and <exec_depend> python-pcg-gazebo-pip </exec_depend> for Python 2.x.","title":"ROS"},{"location":"scripts/","text":"Executable scripts installed with the pcg_gazebo package for command line actions. pcg-generate-occupancy-map \u00b6 Generates an occupancy grid map file in .pgm format from a .world file. The world can be provided either as a ROS topic or a file. Run generate_occupancy_map -h for more information. pcg-generate-occupancy-map -h usage: Generate occupancy grid map from a SDF world file or the current scenario in Gazebo [ -h ] [ --world-file WORLD_FILE ] [ --input-topic INPUT_TOPIC ] [ --xml XML ] [ --from-simulation ] [ --z-levels Z_LEVELS [ Z_LEVELS ... ]] [ --min-z MIN_Z ] [ --max-z MAX_Z ] [ --without-ground-plane ] [ --occupied-color OCCUPIED_COLOR ] [ --free-color FREE_COLOR ] [ --unavailable-color UNAVAILABLE_COLOR ] [ --output-dir OUTPUT_DIR ] [ --output-filename OUTPUT_FILENAME ] [ --static-models-only ] [ --dpi DPI ] [ --figure-width FIGURE_WIDTH ] [ --figure-height FIGURE_HEIGHT ] [ --figure-size-unit FIGURE_SIZE_UNIT ] [ --exclude-contains EXCLUDE_CONTAINS [ EXCLUDE_CONTAINS ... ]] [ --ground-plane-models GROUND_PLANE_MODELS [ GROUND_PLANE_MODELS ... ]] [ --map-x-limits MAP_X_LIMITS [ MAP_X_LIMITS ... ]] [ --map-y-limits MAP_Y_LIMITS [ MAP_Y_LIMITS ... ]] [ --use-visual ] optional arguments: -h, --help show this help message and exit --world-file WORLD_FILE, -w WORLD_FILE SDF world filename --input-topic INPUT_TOPIC Receive world XML file per ROS topic --xml XML Receive world XML as string --from-simulation, -s Retrieve world description from the current Gazebo simulation --z-levels Z_LEVELS [ Z_LEVELS ... ] , -l Z_LEVELS [ Z_LEVELS ... ] Z levels to compute the grid map from --min-z MIN_Z Minimum height for the Z rays in the ray tracing grid --max-z MAX_Z Maximum height for the Z rays in the ray tracing grid --without-ground-plane Ignore ground plane meshes from the map --occupied-color OCCUPIED_COLOR Gray-scale color of the occupied cells --free-color FREE_COLOR Gray-scale color of the free cells --unavailable-color UNAVAILABLE_COLOR Gray-scale color of the unavailable cells --output-dir OUTPUT_DIR Output directory to store the map --output-filename OUTPUT_FILENAME Name of the output map file --static-models-only Uses only static models for the map construction --dpi DPI Figure DPI --figure-width FIGURE_WIDTH Width of the figure --figure-height FIGURE_HEIGHT Height of the figure --figure-size-unit FIGURE_SIZE_UNIT Figure size unit [ cm, m or inch ] --exclude-contains EXCLUDE_CONTAINS [ EXCLUDE_CONTAINS ... ] List of keywords for model names to be excluded from the map --ground-plane-models GROUND_PLANE_MODELS [ GROUND_PLANE_MODELS ... ] List of models that will be considered ground plane --map-x-limits MAP_X_LIMITS [ MAP_X_LIMITS ... ] X limits of the output map in meters --map-y-limits MAP_Y_LIMITS [ MAP_Y_LIMITS ... ] Y limits of the output map in meters --use-visual Use visual meshes instead of collision pcg-generate-sample-world-with-walls \u00b6 Generates a single room with walls with the option to add mesh primitives (e.g. cuboids, cylinders and spheres) to populate it. The wall Gazebo model is per default stored in the local $HOME/.gazebo/models and the world file in $HOME/.gazebo/worlds , but both destinations can be configured. pcg-generate-sample-world-with-walls -h usage: pcg-generate-sample-world-with-walls [ -h ] [ --n-rectangles N_RECTANGLES ] [ --n-points N_POINTS ] [ --wall-thickness WALL_THICKNESS ] [ --wall-height WALL_HEIGHT ] [ --n-cubes N_CUBES ] [ --n-cylinders N_CYLINDERS ] [ --n-spheres N_SPHERES ] [ --set-random-roll ] [ --set-random-pitch ] [ --x-room-range X_ROOM_RANGE ] [ --y-room-range Y_ROOM_RANGE ] [ --world-name WORLD_NAME ] [ --export-world-dir EXPORT_WORLD_DIR ] [ --export-models-dir EXPORT_MODELS_DIR ] [ --preview ] Generates a sample world with walls and objects as primitives optional arguments: -h, --help show this help message and exit --n-rectangles N_RECTANGLES, -r N_RECTANGLES Number of rectangles to merge to generate the room --n-points N_POINTS, -p N_POINTS Number of points to triangulate to generate the room --wall-thickness WALL_THICKNESS, -t WALL_THICKNESS Thickness of the walls --wall-height WALL_HEIGHT, -g WALL_HEIGHT Height of the walls --n-cubes N_CUBES, -c N_CUBES Number of cubes to place in the world --n-cylinders N_CYLINDERS, -l N_CYLINDERS Number of cylinders to place in the world --n-spheres N_SPHERES, -s N_SPHERES Number of spheres to place in the world --set-random-roll Set the roll angle of the placed objects with a random variable --set-random-pitch Set the pitch angle of the placed objects with a random variable --x-room-range X_ROOM_RANGE, -x X_ROOM_RANGE Range in X to generate the rectangles or points --y-room-range Y_ROOM_RANGE, -y Y_ROOM_RANGE Range in Y to generate the rectangles or points --world-name WORLD_NAME, -n WORLD_NAME Name of output world --export-world-dir EXPORT_WORLD_DIR Export the world --export-models-dir EXPORT_MODELS_DIR Export the models generated --preview Show 3D preview of the created world Usage: pcg-generate-sample-world-with-walls --n-rectangles 1 pcg-generate-sample-world-with-walls --n-rectangles 10 pcg-generate-sample-world-with-walls --n-points 20 pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 5 --n-spheres 5 --n-cylinders 5 pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 5 --n-spheres 5 --n-cylinders 5 --set-random-roll --set-random-pitch pcg-generate-sample-world-with-walls --n-points 20 --n-cubes 10 --preview pcg-generate-world \u00b6 Generates a Gazebo world file from YAML configuration describing the rules for placement of objects, assets to be used and spatial constraints. pcg-generate-world -h usage: Generate the world using the PCG model placement engines [ -h ] [ --config-file CONFIG_FILE ] [ --output-world-file OUTPUT_WORLD_FILE ] [ --verbose ] [ --plot ] [ --plot-width PLOT_WIDTH ] [ --plot-height PLOT_HEIGHT ] [ --output-topic OUTPUT_TOPIC ] [ --with-sun ] [ --with-ground-plane ] [ --run ] [ --physics PHYSICS ] optional arguments: -h, --help show this help message and exit --config-file CONFIG_FILE Configuration file ( YAML format ) with the PCG engines specification and assets lists --output-world-file OUTPUT_WORLD_FILE Output SDF world file --verbose Set the output of the world generator as verbose --plot Create bokeh plot of the object and workspace footprints --plot-width PLOT_WIDTH Width of the plot --plot-height PLOT_HEIGHT Height of the plot --output-topic OUTPUT_TOPIC Optional output topic to publish the resulting XML --with-sun Add default sun model to world --with-ground-plane Add default ground_plane model to world --run Run Gazebo with the generated world --physics PHYSICS Physics engine to start with Gazebo Examples launch_pcg_world script Samples of world configuration files pcg-inspect-asset \u00b6 pcg-inspect-asset -h usage: List all elements from a model or world [ -h ] [ --filename FILENAME ] [ --gazebo-model GAZEBO_MODEL ] [ --print-xml ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME --gazebo-model GAZEBO_MODEL, -g GAZEBO_MODEL --print-xml, -p pcg-install-gazebo-assets \u00b6 pcg-install-gazebo-assets -h usage: pcg-install-gazebo-assets [ -h ] [ --tarball TARBALL ] [ --dir DIR ] [ --filename FILENAME ] [ --models-path MODELS_PATH ] [ --add-timestamp ] [ --prefix PREFIX ] [ --name NAME ] Open and install Gazebo assets ( media, models and world ) in the default Gazebo resource paths < $HOME /.gazebo> optional arguments: -h, --help show this help message and exit --tarball TARBALL, -t TARBALL Filename of the tarball containing the simulation assets. The tarball must contain either ( 1 ) a Gazebo model, including at least model.config and model.sdf files or ( 2 ) a models and/or a worlds folder --dir DIR, -d DIR A folder containing ( 1 ) a Gazebo model, including at least model.config and model.sdf files or ( 2 ) a models and/or a worlds folder --filename FILENAME, -f FILENAME A SDF, URDF or XACRO file to be installed as a Gazebo model or world --models-path MODELS_PATH, -m MODELS_PATH Optional custom models path necessary for parsing the asset to be installed --add-timestamp, -a Adds timestamp to the asset name as a suffix --prefix PREFIX, -p PREFIX Prefix string to be added to the asset name installed --name NAME, -n NAME New name of the asset to be installed Usage: pcg-install-gazebo-assets --tarball FILENAME pcg-install-gazebo-assets --filename FILENAME pcg-install-gazebo-assets --dir FOLDER --prefix PREFIX --add-timestamp --name NEW_ASSET_NAME pcg-install-gazebo-assets --tarball FILENAME --prefix PREFIX --add-timestamp pcg-list-gazebo-models \u00b6 Lists all the static Gazebo models found in the ROS paths and $HOME/.gazebo/models . Example $ pcg-list-gazebo-models pcg-populate-world \u00b6 pcg-populate-world -h usage: pcg-populate-world [ -h ] [ --world WORLD ] [ --config CONFIG ] [ --model MODEL [ MODEL ... ]] [ --num NUM [ NUM ... ]] [ --min-distance MIN_DISTANCE [ MIN_DISTANCE ... ]] [ --static STATIC [ STATIC ... ]] [ --export-filename EXPORT_FILENAME ] [ --custom-models-path CUSTOM_MODELS_PATH [ CUSTOM_MODELS_PATH ... ]] [ --random-roll ] [ --random-pitch ] [ --random-yaw ] [ --workspace WORKSPACE ] [ --tangent-to-ground ] [ --preview ] This script will either take a Gazebo world ( or use an empty one if none is provided ) and populate it w ith models placed within a workspace.The workspace can be either provided as a set of 2D or 3D points, the convex hull of the models in the world, or the free space found in the world grid map. optional arguments: -h, --help show this help message and exit --world WORLD, -w WORLD Gazebo world as file or XML input to be populated --config CONFIG, -c CONFIG YAML file with the configuration for engines and models to be added to the world --model MODEL [ MODEL ... ] , -m MODEL [ MODEL ... ] Name of Gazebo model to include in the world --num NUM [ NUM ... ] , -n NUM [ NUM ... ] Number of elements to add to world ( use -1 if no maximum limit is necessary ) --min-distance MIN_DISTANCE [ MIN_DISTANCE ... ] , -d MIN_DISTANCE [ MIN_DISTANCE ... ] Minimum distance between objects ( either for all models or per model --static STATIC [ STATIC ... ] , -s STATIC [ STATIC ... ] Whether the model should be static or not --export-filename EXPORT_FILENAME, -f EXPORT_FILENAME Name of the filename to export the generated world. If none is provided, the same filename with a datetime suffix will be used. --custom-models-path CUSTOM_MODELS_PATH [ CUSTOM_MODELS_PATH ... ] , -p CUSTOM_MODELS_PATH [ CUSTOM_MODELS_PATH ... ] Custom folder containing Gazebo models --random-roll For random engines, the roll angle will also be randomized --random-pitch For random engines, the pitch angle will also be randomized --random-yaw For random engines, the yaw angle will also be randomized --workspace WORKSPACE, -k WORKSPACE Name of model or set of coordinates provided as ( 1 ) [( x, y, z ) , ( x, y, z ) , ... ] for a 3D workpace, ( 2 ) [( x, y ) , ( x, y ) , ... ] for a 2D workspace, ( 3 ) name of models in the provided world that delimit the workspace ( e.g. walls ) . ( 4 ) \"gridmap\" to compute a grid map of the input world and place objects in the free space foundIf no workspace is defined and there is a world with models provided, the workspace will be the convex hull around all existing models. If no world is provided, an area of 20 x 20 m on the ground plane will be set as the workspace --tangent-to-ground, -t Place all models tangent to the ground plane --preview Preview the workspace and generated world pcg-populate-world --model MODEL_1 MODEL_2 --num 3 3 --min-distance 0 .2 --static 1 # Models 1 and 2 must be Gazebo models pcg-populate-world --model random_box --num 2 # Add two random boxes to an empty world pcg-populate-world --model random_box random_cylinder random_sphere --num -1 -1 -1 --tangent-to-ground # Add as many random boxes, cylinders and spheres as possible in the default workspace and place them tangent to the ground plane pcg-populate-world --model MESH_FILENAME --num 1 # Add mesh as model in the world pcg-populate-world --world WORLD_FILE --model MODEL_1 --num 5 # Add MODEL_1 to world loaded from file pcg-preview-sdf \u00b6 Opens a SDF file (either .sdf or .world ) and shows a 3D preview of the geometries and meshes. The input SDF file must contain either a world or a model. Beware that if the world or model includes another model or meshes using the prefixes model:// , that the included models must be in the Gazebo resources path so that they can be also parsed. pcg-preview-sdf -h usage: Parse a SDF file ( .sdf or .world ) and display its geometries and meshes [ -h ] [ --filename FILENAME ] [ --collision ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME SDF file ( .sdf or .world ) --collision, -c View collision meshes Example pcg-preview-sdf --filename SDF_FILENAME # Preview of the visual meshes pcg-preview-sdf --filename SDF_FILENAME --collision # Preview of the collision meshes pcg-preview-urdf \u00b6 Opens an URDF file ( .urdf ) or a XACRO file ( .xacro ) that will be parsed into an URDF file, and shows a 3D preview of the geometries and meshes. Beware that if the model includes meshes and includes other XACRO files, they should also be reachable within the ROS paths so that the model can be parsed. pcg-preview-urdf -h usage: Parse a URDF file and display its geometries and meshes. XACRO files can also be provided and will processed to generate the URDF files. [ -h ] [ --filename FILENAME ] [ --collision ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME URDF or XACRO file --collision, -c View collision meshes Example pcg-preview-urdf --filename URDF_OR_XACRO_FILENAME # Preview of the visual meshes pcg-preview-urdf --filename URDF_OR_XACRO_FILENAME --collision # Preview of the collision meshes pcg-print-xml-element \u00b6 This tool can be called to retrieve information on SDF, URDF or SDF Config elements. They can be displayed in XML format or the script can list all the children and attributes of an XML element. pcg-print-xml-element -h usage: pcg-print-xml-element [ -h ] [ --sdf ] [ --urdf ] [ --sdf-config ] [ --tag TAG ] [ --list ] [ --xml ] [ --description ] Print XML elements ( SDF, URDF or SDF Config ) optional arguments: -h, --help show this help message and exit --sdf Retrieve information on SDF element --urdf Retrieve information on URDF element --sdf-config Retrieve information on SDF Config element --tag TAG, -t TAG Name of the XML element --list, -l List tags of all elements available --xml, -x Output the element as XML --description, -d Print information on the children of the XML element Usage: pcg-print-xml-element --sdf --list pcg-print-xml-element --urdf --list pcg-print-xml-element --sdf-config --list pcg-print-xml-element --sdf --tag NAME --xml pcg-print-xml-element --sdf --tag NAME --description Example pcg-print-xml-element --sdf --list pcg-print-xml-element --urdf --list pcg-print-xml-element --sdf-config --list pcg-print-xml-element --sdf --tag NAME --xml pcg-print-xml-element --sdf --tag NAME --description pcg-process-jinja-template \u00b6 Generates a file from a Jinja template. Run pcg-process-jinja-template -h for more information. pcg-process-jinja-template -h usage: pcg-process-jinja-template [ -h ] [ --input-template INPUT_TEMPLATE ] [ --param-file PARAM_FILE ] [ --output-filename OUTPUT_FILENAME ] [ --include-dir INCLUDE_DIR ] [ --param PARAM ] [ --sdf ] [ --sdf-config ] [ --urdf ] [ --merge-nested-models ] Parse Jinja template optional arguments: -h, --help show this help message and exit --input-template INPUT_TEMPLATE, -i INPUT_TEMPLATE Input template file --param-file PARAM_FILE, -f PARAM_FILE YAML file with parameters to be rendered in the final output --output-filename OUTPUT_FILENAME, -o OUTPUT_FILENAME Output file to store the parsed file --include-dir INCLUDE_DIR, -d INCLUDE_DIR Input directory for template modules --param PARAM, -p PARAM Model parameter to be replaced in the template --sdf Output template is a SDF file and will be verified --sdf-config Output template is a SDF model configuration file and will be verified --urdf Output template is an URDF file and will be verified --merge-nested-models For SDF descriptions, merge nested models before generating final SDF, in case there are any Examples gen_model_from_template script Samples of model templates written in Jinja pcg-run-model-factory \u00b6 Runs a model factory function from the creators module using a YAML file input with the model description. Run pcg-run-model-factory -h for more information. pcg-run-model-factory -h usage: Imports a YAML file with the description of a model and/or description of the factory parameters to generate models procedurally [ -h ] [ --config-file CONFIG_FILE ] [ --config CONFIG ] [ --print ] [ --store-model ] [ --store-dir STORE_DIR ] [ --overwrite ] [ --spawn ] [ --spawn-random-positions ] optional arguments: -h, --help show this help message and exit --config-file CONFIG_FILE, -f CONFIG_FILE YAML file with the model generator configuration --config CONFIG, -c CONFIG Enter the configuration in the JSON format as a string --print Print models as SDF --store-model Store the generated models as Gazebo models --store-dir STORE_DIR Output directory to store the generated models --overwrite Overwrite models with the same name when storing --spawn Spawn the generated models if Gazebo is running --spawn-random-positions Spawn models on random positions Examples gen_model_from_factory_config script Samples of model factory configuration files pcg-sdf2urdf \u00b6 Converts a SDF file into an URDF file. Run pcg-sdf2urdf -h for more information. pcg-sdf2urdf -h usage: pcg-sdf2urdf [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --input-topic INPUT_TOPIC ] [ --output-filename OUTPUT_FILENAME ] [ --output-parameter OUTPUT_PARAMETER ] [ --print ] [ --verbose ] Convert URDF to SDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the SDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the SDF robot description --xml XML, -x XML XML text input with the SDF robot description --input-topic INPUT_TOPIC, -t INPUT_TOPIC ROS topic that will deliver the XML text input with the SDF robot description --output-filename OUTPUT_FILENAME, -o OUTPUT_FILENAME Output file to store the converted URDF file --output-parameter OUTPUT_PARAMETER, -r OUTPUT_PARAMETER Output ROS parameter to store the converted URDF file --print Print the file --verbose, -v Run on verbose mode pcg-sdflint \u00b6 Checks a SDF file for errors. Run pcg-sdflint -h for more information. pcg-sdflint -h usage: pcg-sdflint [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --print ] [ --verbose ] Linter for SDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the SDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the SDF robot description or XACRO filename to generate it --xml XML, -x XML XML text input with the SDF robot description --print Print the file --verbose, -v Run on verbose mode pcg-spawn-sdf-model \u00b6 Spawns a model described in SDF format in the current running instance of Gazebo. The input SDF data can be provided via ROS parameter and the simulation can be set to unpause after the model has been spawned. This script starts a ROS node and therefore roscore must be already running. Run pcg-spawn-sdf-model -h for more information. pcg-spawn-sdf-model -h usage: pcg-spawn-sdf-model [ -h ] [ --param_name PARAM_NAME ] [ --robot_name ROBOT_NAME ] [ --x X ] [ --y Y ] [ --z Z ] [ --roll ROLL ] [ --pitch PITCH ] [ --yaw YAW ] [ --unpause-simulation ] Spawn SDF model after trigger optional arguments: -h, --help show this help message and exit --param_name PARAM_NAME Input parameter name where the SDF content is stored --robot_name ROBOT_NAME Name of the robot model --x X X coordinate of the spawning position in meters --y Y Y coordinate of the spawning position in meters --z Z Z coordinate of the spawning position in meters --roll ROLL Roll angle of the spawning position in radians --pitch PITCH Pitch angle of the spawning position in radians --yaw YAW Yaw angle of the spawning position in radians --unpause-simulation Unpause simulation once the model has been spawned pcg-start-gazebo-world \u00b6 Starts a Gazebo simulation from a .world file. The .world file can be either provided as a file or through a ROS topic. This script can be used start a world only when description is available via topic. Run pcg-start-gazebo-world -h for more information. pcg-start-gazebo-world -h usage: pcg-start-gazebo-world [ -h ] [ --input_topic INPUT_TOPIC ] [ --input_world_filename INPUT_WORLD_FILENAME ] [ --physics PHYSICS ] [ --paused PAUSED ] [ --gui GUI ] Start Gazebo world from file optional arguments: -h, --help show this help message and exit --input_topic INPUT_TOPIC, -t INPUT_TOPIC ROS topic that will deliver the XML text input with the SDF robot description --input_world_filename INPUT_WORLD_FILENAME, -f INPUT_WORLD_FILENAME Input --physics PHYSICS Name of the physics engine --paused PAUSED Start simulation paused --gui GUI Do not start Gazebo client pcg-urdf2sdf \u00b6 Converts an URDF file into a SDF file. Run pcg-urdf2sdf -h for more information. pcg-urdf2sdf -h usage: pcg-urdf2sdf [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --input-topic INPUT_TOPIC ] [ --output-filename OUTPUT_FILENAME ] [ --output-parameter OUTPUT_PARAMETER ] [ --output-gazebo-model-path OUTPUT_GAZEBO_MODEL_PATH ] [ --create-gazebo-model ] [ --model-name MODEL_NAME ] [ --print ] [ --sdf-version SDF_VERSION ] [ --verbose ] Convert SDF to URDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the URDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the URDF robot description --xml XML, -x XML XML text input with the URDF robot description --input-topic INPUT_TOPIC, -t INPUT_TOPIC ROS topic that will deliver the XML text input with the URDF robot description --output-filename OUTPUT_FILENAME, -o OUTPUT_FILENAME Output file to store the converted SDF file --output-parameter OUTPUT_PARAMETER, -r OUTPUT_PARAMETER Output ROS parameter to store the converted SDF file --output-gazebo-model-path OUTPUT_GAZEBO_MODEL_PATH, -gp OUTPUT_GAZEBO_MODEL_PATH Output path for the Gazebo model --create-gazebo-model, -g Export SDF as a static Gazebo model --model-name MODEL_NAME, -m MODEL_NAME Name of the model being generated --print Print the file --sdf-version SDF_VERSION Version of the SDF file being generated --verbose, -v Run on verbose mode pcg-urdflint \u00b6 Checks an URDF file for errors. If a XACRO file is provided, it will be processed using the default xacro parser and the resulting URDF will be checked for errors. Run pcg-urdflint -h for more information. pcg-urdflint -h usage: pcg-urdflint [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --print ] [ --verbose ] Convert URDF to URDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the URDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the URDF robot description or XACRO file to generate it --xml XML, -x XML XML text input with the URDF robot description --print Print the file --verbose, -v Run on verbose mode pcg-view-gazebo-model \u00b6 Opens a static Gazebo model and displays its geometries. To see the tags of all Gazebo models available in your system, run pcg-list-gazebo-models . pcg-view-gazebo-model -h usage: Open and display a Gazebo model [ -h ] [ --model MODEL ] [ --collision ] optional arguments: -h, --help show this help message and exit --model MODEL, -m MODEL Gazebo model name --collision, -c View collision meshes Examples $ pcg-view-gazebo-model --model MODEL_NAME # To display the visual meshes $ pcg-view-gazebo-model --model MODEL_NAME --collision # To display the collision meshes pcg-view-mesh \u00b6 Opens a mesh file and displays it. Run pcg-view-mesh -h for more information. pcg-view-mesh -h usage: Open and display a mesh [ -h ] [ --filename FILENAME ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME Mesh filename","title":"Scripts"},{"location":"scripts/#pcg-generate-occupancy-map","text":"Generates an occupancy grid map file in .pgm format from a .world file. The world can be provided either as a ROS topic or a file. Run generate_occupancy_map -h for more information. pcg-generate-occupancy-map -h usage: Generate occupancy grid map from a SDF world file or the current scenario in Gazebo [ -h ] [ --world-file WORLD_FILE ] [ --input-topic INPUT_TOPIC ] [ --xml XML ] [ --from-simulation ] [ --z-levels Z_LEVELS [ Z_LEVELS ... ]] [ --min-z MIN_Z ] [ --max-z MAX_Z ] [ --without-ground-plane ] [ --occupied-color OCCUPIED_COLOR ] [ --free-color FREE_COLOR ] [ --unavailable-color UNAVAILABLE_COLOR ] [ --output-dir OUTPUT_DIR ] [ --output-filename OUTPUT_FILENAME ] [ --static-models-only ] [ --dpi DPI ] [ --figure-width FIGURE_WIDTH ] [ --figure-height FIGURE_HEIGHT ] [ --figure-size-unit FIGURE_SIZE_UNIT ] [ --exclude-contains EXCLUDE_CONTAINS [ EXCLUDE_CONTAINS ... ]] [ --ground-plane-models GROUND_PLANE_MODELS [ GROUND_PLANE_MODELS ... ]] [ --map-x-limits MAP_X_LIMITS [ MAP_X_LIMITS ... ]] [ --map-y-limits MAP_Y_LIMITS [ MAP_Y_LIMITS ... ]] [ --use-visual ] optional arguments: -h, --help show this help message and exit --world-file WORLD_FILE, -w WORLD_FILE SDF world filename --input-topic INPUT_TOPIC Receive world XML file per ROS topic --xml XML Receive world XML as string --from-simulation, -s Retrieve world description from the current Gazebo simulation --z-levels Z_LEVELS [ Z_LEVELS ... ] , -l Z_LEVELS [ Z_LEVELS ... ] Z levels to compute the grid map from --min-z MIN_Z Minimum height for the Z rays in the ray tracing grid --max-z MAX_Z Maximum height for the Z rays in the ray tracing grid --without-ground-plane Ignore ground plane meshes from the map --occupied-color OCCUPIED_COLOR Gray-scale color of the occupied cells --free-color FREE_COLOR Gray-scale color of the free cells --unavailable-color UNAVAILABLE_COLOR Gray-scale color of the unavailable cells --output-dir OUTPUT_DIR Output directory to store the map --output-filename OUTPUT_FILENAME Name of the output map file --static-models-only Uses only static models for the map construction --dpi DPI Figure DPI --figure-width FIGURE_WIDTH Width of the figure --figure-height FIGURE_HEIGHT Height of the figure --figure-size-unit FIGURE_SIZE_UNIT Figure size unit [ cm, m or inch ] --exclude-contains EXCLUDE_CONTAINS [ EXCLUDE_CONTAINS ... ] List of keywords for model names to be excluded from the map --ground-plane-models GROUND_PLANE_MODELS [ GROUND_PLANE_MODELS ... ] List of models that will be considered ground plane --map-x-limits MAP_X_LIMITS [ MAP_X_LIMITS ... ] X limits of the output map in meters --map-y-limits MAP_Y_LIMITS [ MAP_Y_LIMITS ... ] Y limits of the output map in meters --use-visual Use visual meshes instead of collision","title":"pcg-generate-occupancy-map"},{"location":"scripts/#pcg-generate-sample-world-with-walls","text":"Generates a single room with walls with the option to add mesh primitives (e.g. cuboids, cylinders and spheres) to populate it. The wall Gazebo model is per default stored in the local $HOME/.gazebo/models and the world file in $HOME/.gazebo/worlds , but both destinations can be configured. pcg-generate-sample-world-with-walls -h usage: pcg-generate-sample-world-with-walls [ -h ] [ --n-rectangles N_RECTANGLES ] [ --n-points N_POINTS ] [ --wall-thickness WALL_THICKNESS ] [ --wall-height WALL_HEIGHT ] [ --n-cubes N_CUBES ] [ --n-cylinders N_CYLINDERS ] [ --n-spheres N_SPHERES ] [ --set-random-roll ] [ --set-random-pitch ] [ --x-room-range X_ROOM_RANGE ] [ --y-room-range Y_ROOM_RANGE ] [ --world-name WORLD_NAME ] [ --export-world-dir EXPORT_WORLD_DIR ] [ --export-models-dir EXPORT_MODELS_DIR ] [ --preview ] Generates a sample world with walls and objects as primitives optional arguments: -h, --help show this help message and exit --n-rectangles N_RECTANGLES, -r N_RECTANGLES Number of rectangles to merge to generate the room --n-points N_POINTS, -p N_POINTS Number of points to triangulate to generate the room --wall-thickness WALL_THICKNESS, -t WALL_THICKNESS Thickness of the walls --wall-height WALL_HEIGHT, -g WALL_HEIGHT Height of the walls --n-cubes N_CUBES, -c N_CUBES Number of cubes to place in the world --n-cylinders N_CYLINDERS, -l N_CYLINDERS Number of cylinders to place in the world --n-spheres N_SPHERES, -s N_SPHERES Number of spheres to place in the world --set-random-roll Set the roll angle of the placed objects with a random variable --set-random-pitch Set the pitch angle of the placed objects with a random variable --x-room-range X_ROOM_RANGE, -x X_ROOM_RANGE Range in X to generate the rectangles or points --y-room-range Y_ROOM_RANGE, -y Y_ROOM_RANGE Range in Y to generate the rectangles or points --world-name WORLD_NAME, -n WORLD_NAME Name of output world --export-world-dir EXPORT_WORLD_DIR Export the world --export-models-dir EXPORT_MODELS_DIR Export the models generated --preview Show 3D preview of the created world Usage: pcg-generate-sample-world-with-walls --n-rectangles 1 pcg-generate-sample-world-with-walls --n-rectangles 10 pcg-generate-sample-world-with-walls --n-points 20 pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 5 --n-spheres 5 --n-cylinders 5 pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 5 --n-spheres 5 --n-cylinders 5 --set-random-roll --set-random-pitch pcg-generate-sample-world-with-walls --n-points 20 --n-cubes 10 --preview","title":"pcg-generate-sample-world-with-walls"},{"location":"scripts/#pcg-generate-world","text":"Generates a Gazebo world file from YAML configuration describing the rules for placement of objects, assets to be used and spatial constraints. pcg-generate-world -h usage: Generate the world using the PCG model placement engines [ -h ] [ --config-file CONFIG_FILE ] [ --output-world-file OUTPUT_WORLD_FILE ] [ --verbose ] [ --plot ] [ --plot-width PLOT_WIDTH ] [ --plot-height PLOT_HEIGHT ] [ --output-topic OUTPUT_TOPIC ] [ --with-sun ] [ --with-ground-plane ] [ --run ] [ --physics PHYSICS ] optional arguments: -h, --help show this help message and exit --config-file CONFIG_FILE Configuration file ( YAML format ) with the PCG engines specification and assets lists --output-world-file OUTPUT_WORLD_FILE Output SDF world file --verbose Set the output of the world generator as verbose --plot Create bokeh plot of the object and workspace footprints --plot-width PLOT_WIDTH Width of the plot --plot-height PLOT_HEIGHT Height of the plot --output-topic OUTPUT_TOPIC Optional output topic to publish the resulting XML --with-sun Add default sun model to world --with-ground-plane Add default ground_plane model to world --run Run Gazebo with the generated world --physics PHYSICS Physics engine to start with Gazebo Examples launch_pcg_world script Samples of world configuration files","title":"pcg-generate-world"},{"location":"scripts/#pcg-inspect-asset","text":"pcg-inspect-asset -h usage: List all elements from a model or world [ -h ] [ --filename FILENAME ] [ --gazebo-model GAZEBO_MODEL ] [ --print-xml ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME --gazebo-model GAZEBO_MODEL, -g GAZEBO_MODEL --print-xml, -p","title":"pcg-inspect-asset"},{"location":"scripts/#pcg-install-gazebo-assets","text":"pcg-install-gazebo-assets -h usage: pcg-install-gazebo-assets [ -h ] [ --tarball TARBALL ] [ --dir DIR ] [ --filename FILENAME ] [ --models-path MODELS_PATH ] [ --add-timestamp ] [ --prefix PREFIX ] [ --name NAME ] Open and install Gazebo assets ( media, models and world ) in the default Gazebo resource paths < $HOME /.gazebo> optional arguments: -h, --help show this help message and exit --tarball TARBALL, -t TARBALL Filename of the tarball containing the simulation assets. The tarball must contain either ( 1 ) a Gazebo model, including at least model.config and model.sdf files or ( 2 ) a models and/or a worlds folder --dir DIR, -d DIR A folder containing ( 1 ) a Gazebo model, including at least model.config and model.sdf files or ( 2 ) a models and/or a worlds folder --filename FILENAME, -f FILENAME A SDF, URDF or XACRO file to be installed as a Gazebo model or world --models-path MODELS_PATH, -m MODELS_PATH Optional custom models path necessary for parsing the asset to be installed --add-timestamp, -a Adds timestamp to the asset name as a suffix --prefix PREFIX, -p PREFIX Prefix string to be added to the asset name installed --name NAME, -n NAME New name of the asset to be installed Usage: pcg-install-gazebo-assets --tarball FILENAME pcg-install-gazebo-assets --filename FILENAME pcg-install-gazebo-assets --dir FOLDER --prefix PREFIX --add-timestamp --name NEW_ASSET_NAME pcg-install-gazebo-assets --tarball FILENAME --prefix PREFIX --add-timestamp","title":"pcg-install-gazebo-assets"},{"location":"scripts/#pcg-list-gazebo-models","text":"Lists all the static Gazebo models found in the ROS paths and $HOME/.gazebo/models . Example $ pcg-list-gazebo-models","title":"pcg-list-gazebo-models"},{"location":"scripts/#pcg-populate-world","text":"pcg-populate-world -h usage: pcg-populate-world [ -h ] [ --world WORLD ] [ --config CONFIG ] [ --model MODEL [ MODEL ... ]] [ --num NUM [ NUM ... ]] [ --min-distance MIN_DISTANCE [ MIN_DISTANCE ... ]] [ --static STATIC [ STATIC ... ]] [ --export-filename EXPORT_FILENAME ] [ --custom-models-path CUSTOM_MODELS_PATH [ CUSTOM_MODELS_PATH ... ]] [ --random-roll ] [ --random-pitch ] [ --random-yaw ] [ --workspace WORKSPACE ] [ --tangent-to-ground ] [ --preview ] This script will either take a Gazebo world ( or use an empty one if none is provided ) and populate it w ith models placed within a workspace.The workspace can be either provided as a set of 2D or 3D points, the convex hull of the models in the world, or the free space found in the world grid map. optional arguments: -h, --help show this help message and exit --world WORLD, -w WORLD Gazebo world as file or XML input to be populated --config CONFIG, -c CONFIG YAML file with the configuration for engines and models to be added to the world --model MODEL [ MODEL ... ] , -m MODEL [ MODEL ... ] Name of Gazebo model to include in the world --num NUM [ NUM ... ] , -n NUM [ NUM ... ] Number of elements to add to world ( use -1 if no maximum limit is necessary ) --min-distance MIN_DISTANCE [ MIN_DISTANCE ... ] , -d MIN_DISTANCE [ MIN_DISTANCE ... ] Minimum distance between objects ( either for all models or per model --static STATIC [ STATIC ... ] , -s STATIC [ STATIC ... ] Whether the model should be static or not --export-filename EXPORT_FILENAME, -f EXPORT_FILENAME Name of the filename to export the generated world. If none is provided, the same filename with a datetime suffix will be used. --custom-models-path CUSTOM_MODELS_PATH [ CUSTOM_MODELS_PATH ... ] , -p CUSTOM_MODELS_PATH [ CUSTOM_MODELS_PATH ... ] Custom folder containing Gazebo models --random-roll For random engines, the roll angle will also be randomized --random-pitch For random engines, the pitch angle will also be randomized --random-yaw For random engines, the yaw angle will also be randomized --workspace WORKSPACE, -k WORKSPACE Name of model or set of coordinates provided as ( 1 ) [( x, y, z ) , ( x, y, z ) , ... ] for a 3D workpace, ( 2 ) [( x, y ) , ( x, y ) , ... ] for a 2D workspace, ( 3 ) name of models in the provided world that delimit the workspace ( e.g. walls ) . ( 4 ) \"gridmap\" to compute a grid map of the input world and place objects in the free space foundIf no workspace is defined and there is a world with models provided, the workspace will be the convex hull around all existing models. If no world is provided, an area of 20 x 20 m on the ground plane will be set as the workspace --tangent-to-ground, -t Place all models tangent to the ground plane --preview Preview the workspace and generated world pcg-populate-world --model MODEL_1 MODEL_2 --num 3 3 --min-distance 0 .2 --static 1 # Models 1 and 2 must be Gazebo models pcg-populate-world --model random_box --num 2 # Add two random boxes to an empty world pcg-populate-world --model random_box random_cylinder random_sphere --num -1 -1 -1 --tangent-to-ground # Add as many random boxes, cylinders and spheres as possible in the default workspace and place them tangent to the ground plane pcg-populate-world --model MESH_FILENAME --num 1 # Add mesh as model in the world pcg-populate-world --world WORLD_FILE --model MODEL_1 --num 5 # Add MODEL_1 to world loaded from file","title":"pcg-populate-world"},{"location":"scripts/#pcg-preview-sdf","text":"Opens a SDF file (either .sdf or .world ) and shows a 3D preview of the geometries and meshes. The input SDF file must contain either a world or a model. Beware that if the world or model includes another model or meshes using the prefixes model:// , that the included models must be in the Gazebo resources path so that they can be also parsed. pcg-preview-sdf -h usage: Parse a SDF file ( .sdf or .world ) and display its geometries and meshes [ -h ] [ --filename FILENAME ] [ --collision ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME SDF file ( .sdf or .world ) --collision, -c View collision meshes Example pcg-preview-sdf --filename SDF_FILENAME # Preview of the visual meshes pcg-preview-sdf --filename SDF_FILENAME --collision # Preview of the collision meshes","title":"pcg-preview-sdf"},{"location":"scripts/#pcg-preview-urdf","text":"Opens an URDF file ( .urdf ) or a XACRO file ( .xacro ) that will be parsed into an URDF file, and shows a 3D preview of the geometries and meshes. Beware that if the model includes meshes and includes other XACRO files, they should also be reachable within the ROS paths so that the model can be parsed. pcg-preview-urdf -h usage: Parse a URDF file and display its geometries and meshes. XACRO files can also be provided and will processed to generate the URDF files. [ -h ] [ --filename FILENAME ] [ --collision ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME URDF or XACRO file --collision, -c View collision meshes Example pcg-preview-urdf --filename URDF_OR_XACRO_FILENAME # Preview of the visual meshes pcg-preview-urdf --filename URDF_OR_XACRO_FILENAME --collision # Preview of the collision meshes","title":"pcg-preview-urdf"},{"location":"scripts/#pcg-print-xml-element","text":"This tool can be called to retrieve information on SDF, URDF or SDF Config elements. They can be displayed in XML format or the script can list all the children and attributes of an XML element. pcg-print-xml-element -h usage: pcg-print-xml-element [ -h ] [ --sdf ] [ --urdf ] [ --sdf-config ] [ --tag TAG ] [ --list ] [ --xml ] [ --description ] Print XML elements ( SDF, URDF or SDF Config ) optional arguments: -h, --help show this help message and exit --sdf Retrieve information on SDF element --urdf Retrieve information on URDF element --sdf-config Retrieve information on SDF Config element --tag TAG, -t TAG Name of the XML element --list, -l List tags of all elements available --xml, -x Output the element as XML --description, -d Print information on the children of the XML element Usage: pcg-print-xml-element --sdf --list pcg-print-xml-element --urdf --list pcg-print-xml-element --sdf-config --list pcg-print-xml-element --sdf --tag NAME --xml pcg-print-xml-element --sdf --tag NAME --description Example pcg-print-xml-element --sdf --list pcg-print-xml-element --urdf --list pcg-print-xml-element --sdf-config --list pcg-print-xml-element --sdf --tag NAME --xml pcg-print-xml-element --sdf --tag NAME --description","title":"pcg-print-xml-element"},{"location":"scripts/#pcg-process-jinja-template","text":"Generates a file from a Jinja template. Run pcg-process-jinja-template -h for more information. pcg-process-jinja-template -h usage: pcg-process-jinja-template [ -h ] [ --input-template INPUT_TEMPLATE ] [ --param-file PARAM_FILE ] [ --output-filename OUTPUT_FILENAME ] [ --include-dir INCLUDE_DIR ] [ --param PARAM ] [ --sdf ] [ --sdf-config ] [ --urdf ] [ --merge-nested-models ] Parse Jinja template optional arguments: -h, --help show this help message and exit --input-template INPUT_TEMPLATE, -i INPUT_TEMPLATE Input template file --param-file PARAM_FILE, -f PARAM_FILE YAML file with parameters to be rendered in the final output --output-filename OUTPUT_FILENAME, -o OUTPUT_FILENAME Output file to store the parsed file --include-dir INCLUDE_DIR, -d INCLUDE_DIR Input directory for template modules --param PARAM, -p PARAM Model parameter to be replaced in the template --sdf Output template is a SDF file and will be verified --sdf-config Output template is a SDF model configuration file and will be verified --urdf Output template is an URDF file and will be verified --merge-nested-models For SDF descriptions, merge nested models before generating final SDF, in case there are any Examples gen_model_from_template script Samples of model templates written in Jinja","title":"pcg-process-jinja-template"},{"location":"scripts/#pcg-run-model-factory","text":"Runs a model factory function from the creators module using a YAML file input with the model description. Run pcg-run-model-factory -h for more information. pcg-run-model-factory -h usage: Imports a YAML file with the description of a model and/or description of the factory parameters to generate models procedurally [ -h ] [ --config-file CONFIG_FILE ] [ --config CONFIG ] [ --print ] [ --store-model ] [ --store-dir STORE_DIR ] [ --overwrite ] [ --spawn ] [ --spawn-random-positions ] optional arguments: -h, --help show this help message and exit --config-file CONFIG_FILE, -f CONFIG_FILE YAML file with the model generator configuration --config CONFIG, -c CONFIG Enter the configuration in the JSON format as a string --print Print models as SDF --store-model Store the generated models as Gazebo models --store-dir STORE_DIR Output directory to store the generated models --overwrite Overwrite models with the same name when storing --spawn Spawn the generated models if Gazebo is running --spawn-random-positions Spawn models on random positions Examples gen_model_from_factory_config script Samples of model factory configuration files","title":"pcg-run-model-factory"},{"location":"scripts/#pcg-sdf2urdf","text":"Converts a SDF file into an URDF file. Run pcg-sdf2urdf -h for more information. pcg-sdf2urdf -h usage: pcg-sdf2urdf [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --input-topic INPUT_TOPIC ] [ --output-filename OUTPUT_FILENAME ] [ --output-parameter OUTPUT_PARAMETER ] [ --print ] [ --verbose ] Convert URDF to SDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the SDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the SDF robot description --xml XML, -x XML XML text input with the SDF robot description --input-topic INPUT_TOPIC, -t INPUT_TOPIC ROS topic that will deliver the XML text input with the SDF robot description --output-filename OUTPUT_FILENAME, -o OUTPUT_FILENAME Output file to store the converted URDF file --output-parameter OUTPUT_PARAMETER, -r OUTPUT_PARAMETER Output ROS parameter to store the converted URDF file --print Print the file --verbose, -v Run on verbose mode","title":"pcg-sdf2urdf"},{"location":"scripts/#pcg-sdflint","text":"Checks a SDF file for errors. Run pcg-sdflint -h for more information. pcg-sdflint -h usage: pcg-sdflint [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --print ] [ --verbose ] Linter for SDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the SDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the SDF robot description or XACRO filename to generate it --xml XML, -x XML XML text input with the SDF robot description --print Print the file --verbose, -v Run on verbose mode","title":"pcg-sdflint"},{"location":"scripts/#pcg-spawn-sdf-model","text":"Spawns a model described in SDF format in the current running instance of Gazebo. The input SDF data can be provided via ROS parameter and the simulation can be set to unpause after the model has been spawned. This script starts a ROS node and therefore roscore must be already running. Run pcg-spawn-sdf-model -h for more information. pcg-spawn-sdf-model -h usage: pcg-spawn-sdf-model [ -h ] [ --param_name PARAM_NAME ] [ --robot_name ROBOT_NAME ] [ --x X ] [ --y Y ] [ --z Z ] [ --roll ROLL ] [ --pitch PITCH ] [ --yaw YAW ] [ --unpause-simulation ] Spawn SDF model after trigger optional arguments: -h, --help show this help message and exit --param_name PARAM_NAME Input parameter name where the SDF content is stored --robot_name ROBOT_NAME Name of the robot model --x X X coordinate of the spawning position in meters --y Y Y coordinate of the spawning position in meters --z Z Z coordinate of the spawning position in meters --roll ROLL Roll angle of the spawning position in radians --pitch PITCH Pitch angle of the spawning position in radians --yaw YAW Yaw angle of the spawning position in radians --unpause-simulation Unpause simulation once the model has been spawned","title":"pcg-spawn-sdf-model"},{"location":"scripts/#pcg-start-gazebo-world","text":"Starts a Gazebo simulation from a .world file. The .world file can be either provided as a file or through a ROS topic. This script can be used start a world only when description is available via topic. Run pcg-start-gazebo-world -h for more information. pcg-start-gazebo-world -h usage: pcg-start-gazebo-world [ -h ] [ --input_topic INPUT_TOPIC ] [ --input_world_filename INPUT_WORLD_FILENAME ] [ --physics PHYSICS ] [ --paused PAUSED ] [ --gui GUI ] Start Gazebo world from file optional arguments: -h, --help show this help message and exit --input_topic INPUT_TOPIC, -t INPUT_TOPIC ROS topic that will deliver the XML text input with the SDF robot description --input_world_filename INPUT_WORLD_FILENAME, -f INPUT_WORLD_FILENAME Input --physics PHYSICS Name of the physics engine --paused PAUSED Start simulation paused --gui GUI Do not start Gazebo client","title":"pcg-start-gazebo-world"},{"location":"scripts/#pcg-urdf2sdf","text":"Converts an URDF file into a SDF file. Run pcg-urdf2sdf -h for more information. pcg-urdf2sdf -h usage: pcg-urdf2sdf [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --input-topic INPUT_TOPIC ] [ --output-filename OUTPUT_FILENAME ] [ --output-parameter OUTPUT_PARAMETER ] [ --output-gazebo-model-path OUTPUT_GAZEBO_MODEL_PATH ] [ --create-gazebo-model ] [ --model-name MODEL_NAME ] [ --print ] [ --sdf-version SDF_VERSION ] [ --verbose ] Convert SDF to URDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the URDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the URDF robot description --xml XML, -x XML XML text input with the URDF robot description --input-topic INPUT_TOPIC, -t INPUT_TOPIC ROS topic that will deliver the XML text input with the URDF robot description --output-filename OUTPUT_FILENAME, -o OUTPUT_FILENAME Output file to store the converted SDF file --output-parameter OUTPUT_PARAMETER, -r OUTPUT_PARAMETER Output ROS parameter to store the converted SDF file --output-gazebo-model-path OUTPUT_GAZEBO_MODEL_PATH, -gp OUTPUT_GAZEBO_MODEL_PATH Output path for the Gazebo model --create-gazebo-model, -g Export SDF as a static Gazebo model --model-name MODEL_NAME, -m MODEL_NAME Name of the model being generated --print Print the file --sdf-version SDF_VERSION Version of the SDF file being generated --verbose, -v Run on verbose mode","title":"pcg-urdf2sdf"},{"location":"scripts/#pcg-urdflint","text":"Checks an URDF file for errors. If a XACRO file is provided, it will be processed using the default xacro parser and the resulting URDF will be checked for errors. Run pcg-urdflint -h for more information. pcg-urdflint -h usage: pcg-urdflint [ -h ] [ --param PARAM ] [ --filename FILENAME ] [ --xml XML ] [ --print ] [ --verbose ] Convert URDF to URDF file optional arguments: -h, --help show this help message and exit --param PARAM, -p PARAM ROS parameter where the URDF robot description is stored --filename FILENAME, -f FILENAME Filename name to the URDF robot description or XACRO file to generate it --xml XML, -x XML XML text input with the URDF robot description --print Print the file --verbose, -v Run on verbose mode","title":"pcg-urdflint"},{"location":"scripts/#pcg-view-gazebo-model","text":"Opens a static Gazebo model and displays its geometries. To see the tags of all Gazebo models available in your system, run pcg-list-gazebo-models . pcg-view-gazebo-model -h usage: Open and display a Gazebo model [ -h ] [ --model MODEL ] [ --collision ] optional arguments: -h, --help show this help message and exit --model MODEL, -m MODEL Gazebo model name --collision, -c View collision meshes Examples $ pcg-view-gazebo-model --model MODEL_NAME # To display the visual meshes $ pcg-view-gazebo-model --model MODEL_NAME --collision # To display the collision meshes","title":"pcg-view-gazebo-model"},{"location":"scripts/#pcg-view-mesh","text":"Opens a mesh file and displays it. Run pcg-view-mesh -h for more information. pcg-view-mesh -h usage: Open and display a mesh [ -h ] [ --filename FILENAME ] optional arguments: -h, --help show this help message and exit --filename FILENAME, -f FILENAME Mesh filename","title":"pcg-view-mesh"},{"location":"single_room_generation/","text":"Single room generation \u00b6 For some applications, generating a sample simple Gazebo scenario with walls and some objects is an interesting feature. It can be used to test navigation algorithms in different worlds generated via scripts. Using the script \u00b6 After installing the package, you can use the pcg-generate-sample-world-with-walls script to generate a simple room with some model primitives (e.g. cuboids, cylinders and spheres) randomly placed in it. The room can be generated out of a single rectangle, run pcg-generate-sample-world-with-walls --n-rectangles 1 --preview The --preview option shows a 3D preview of the generated models. Remove it to avoid opening the pyglet window. Multiple rectangles can also be merged to vary the overall shape of the room. To generate the room from multiple rectangles, run pcg-generate-sample-world-with-walls --n-rectangles 10 --preview Per default the .world output is stored in $HOME/.gazebo/worlds and the wall model generated is stored in $HOME/.gazebo/models . Use the inputs --export-world-dir and --export-models-dir . Be aware that when running the world in Gazebo, the generated model must be reachable via GAZEBO_MODEL_PATH . The world name is per default named pcg_sample.world and the wall model pcg_sample_walls . To change the world name and prefix of the wall name use the input --world-name . Another option is to generate a room out of the triangulation of randomily generated points pcg-generate-sample-world-with-walls --n-points 10 --preview Change the size of the room \u00b6 pcg-generate-sample-world-with-walls --n-rectangles 3 --x-room-range 10 --y-room-range 10 --preview pcg-generate-sample-world-with-walls --n-rectangles 3 --x-room-range 50 --y-room-range 50 --preview Include basic models to the generated world \u00b6 It's possible to already include model primitives in within the walls by providing the number of cubes, cylinders and spheres. The models will be included in the output world file. Use the following example to place these objects in a sample room pcg-generate-sample-world-with-walls --n-rectangles 3 --n-cubes 4 --n-cylinders 4 --n-spheres 4 --preview There is a limit on the amount of models Gazebo can load. If models are missing from the originally generated world file, try regenerating it with less primitives. Other examples can be seen below pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 10 --preview pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 10 --n-spheres 2 --preview pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cylinders 10 --preview pcg-generate-sample-world-with-walls --n-rectangles 10 --n-spheres 10 --preview You can also vary not only the (x, y, yaw) pose of the models and set a random roll and pitch as well by using pcg-generate-sample-world-with-walls --n-rectangles 3 --n-cubes 5 --n-cylinders 5 --n-spheres 5 --set-random-roll --set-random-pitch --preview Running the world in Gazebo \u00b6 As stated before, the default world is stored into $HOME/.gazebo/worlds . The default world is named pcg_sample.world and can be changed by using the script's --world-name . When using the default world name, you can run the world with gazebo $HOME /.gazebo/worlds/pcg_sample.world roslaunch gazebo_ros empty_world.launch world_name: = $HOME /.gazebo/worlds/pcg_sample.world ros2 launch gazebo_ros gazebo.launch.py world: = $HOME /.gazebo/worlds/pcg_sample.world","title":"Single Room Generation"},{"location":"single_room_generation/#single-room-generation","text":"For some applications, generating a sample simple Gazebo scenario with walls and some objects is an interesting feature. It can be used to test navigation algorithms in different worlds generated via scripts.","title":"Single room generation"},{"location":"single_room_generation/#using-the-script","text":"After installing the package, you can use the pcg-generate-sample-world-with-walls script to generate a simple room with some model primitives (e.g. cuboids, cylinders and spheres) randomly placed in it. The room can be generated out of a single rectangle, run pcg-generate-sample-world-with-walls --n-rectangles 1 --preview The --preview option shows a 3D preview of the generated models. Remove it to avoid opening the pyglet window. Multiple rectangles can also be merged to vary the overall shape of the room. To generate the room from multiple rectangles, run pcg-generate-sample-world-with-walls --n-rectangles 10 --preview Per default the .world output is stored in $HOME/.gazebo/worlds and the wall model generated is stored in $HOME/.gazebo/models . Use the inputs --export-world-dir and --export-models-dir . Be aware that when running the world in Gazebo, the generated model must be reachable via GAZEBO_MODEL_PATH . The world name is per default named pcg_sample.world and the wall model pcg_sample_walls . To change the world name and prefix of the wall name use the input --world-name . Another option is to generate a room out of the triangulation of randomily generated points pcg-generate-sample-world-with-walls --n-points 10 --preview","title":"Using the script"},{"location":"single_room_generation/#change-the-size-of-the-room","text":"pcg-generate-sample-world-with-walls --n-rectangles 3 --x-room-range 10 --y-room-range 10 --preview pcg-generate-sample-world-with-walls --n-rectangles 3 --x-room-range 50 --y-room-range 50 --preview","title":"Change the size of the room"},{"location":"single_room_generation/#include-basic-models-to-the-generated-world","text":"It's possible to already include model primitives in within the walls by providing the number of cubes, cylinders and spheres. The models will be included in the output world file. Use the following example to place these objects in a sample room pcg-generate-sample-world-with-walls --n-rectangles 3 --n-cubes 4 --n-cylinders 4 --n-spheres 4 --preview There is a limit on the amount of models Gazebo can load. If models are missing from the originally generated world file, try regenerating it with less primitives. Other examples can be seen below pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 10 --preview pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cubes 10 --n-spheres 2 --preview pcg-generate-sample-world-with-walls --n-rectangles 10 --n-cylinders 10 --preview pcg-generate-sample-world-with-walls --n-rectangles 10 --n-spheres 10 --preview You can also vary not only the (x, y, yaw) pose of the models and set a random roll and pitch as well by using pcg-generate-sample-world-with-walls --n-rectangles 3 --n-cubes 5 --n-cylinders 5 --n-spheres 5 --set-random-roll --set-random-pitch --preview","title":"Include basic models to the generated world"},{"location":"single_room_generation/#running-the-world-in-gazebo","text":"As stated before, the default world is stored into $HOME/.gazebo/worlds . The default world is named pcg_sample.world and can be changed by using the script's --world-name . When using the default world name, you can run the world with gazebo $HOME /.gazebo/worlds/pcg_sample.world roslaunch gazebo_ros empty_world.launch world_name: = $HOME /.gazebo/worlds/pcg_sample.world ros2 launch gazebo_ros gazebo.launch.py world: = $HOME /.gazebo/worlds/pcg_sample.world","title":"Running the world in Gazebo"},{"location":"reference/generators/","text":"pcg_gazebo.generators \u00b6 The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints. AssetsManager \u00b6 AssetsManager ( self ) Assets manager containing all valid Gazebo models and model group generators. This collection should be initialized as a singleton object in order to have a single source of model to all instances of engines, model and world generators. The asset types allowed to be added are: pcg_gazebo.simulation.SimulationModel : Description for a model pcg_gazebo.simulation.Light : Description for light sources pcg_gazebo.simulation.ModelGroup : Group of models and light sources pcg_gazebo.generators.ModelGroupGenerator : Dynamic model group generator dict : Input configuration of the creators factory methods for box , sphere , cylinder and mesh models, for an instance of pcg_gazebo.simulation.Light , or an instance of pcg_gazebo.generators.ModelGroupGenerator str : Name of an existing Gazebo model that can be found in the Gazebo resources path ground_planes \u00b6 list : List of strings with tags of ground plane models tags \u00b6 list : List of strings with all asset tags get_instance \u00b6 AssetsManager . get_instance () Return singleton instance of the AssetsMananger is_model \u00b6 AssetsManager . is_model ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.SimulationModel . Input arguments tag ( type: str ): Tag of the asset. is_light \u00b6 AssetsManager . is_light ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.Light . Input arguments tag ( type: str ): Tag of the asset. is_model_group \u00b6 AssetsManager . is_model_group ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.ModelGroup . Input arguments tag ( type: str ): Tag of the asset. is_gazebo_model \u00b6 AssetsManager . is_gazebo_model ( tag ) Return if asset identified by tag is a Gazebo model found in Gazebo's resources path. Input arguments tag ( type: str ): Tag of the asset. is_model_group_generator \u00b6 AssetsManager . is_model_group_generator ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.generators.ModelGroupGenerator . Input arguments tag ( type: str ): Tag of the asset. is_ground_plane \u00b6 AssetsManager . is_ground_plane ( tag ) Return if asset identified by tag is flagged as a ground plane model. Input arguments tag ( type: str ): Tag of the asset. is_factory_input \u00b6 AssetsManager . is_factory_input ( tag ) Return if asset identified by tag is a dict containing the inputs for a pcg_gazebo.generators.creators factory method to create a box , sphere , cylinder or mesh model. Input arguments tag ( type: str ): Tag of the asset. add \u00b6 AssetsManager . add ( description , tag = None , type = None , parameters = None , include_dir = None , overwrite = True ) Add new asset to the collection. Input arguments description ( type: str , dict , pcg_gazebo.simulation.SimulationModel , pcg_gazebo.simulation.Light , pcg_gazebo.simulation.ModelGroup or pcg_gazebo.generators.ModelGroupGenerator ): Model description. tag ( type: str , default: None ): Asset's tag. If None is provided, the input description must have an attribute name which will be used as a tag, otherwise the function returns False . type ( type: str , default: None ): When the provided description is dict , the type of asset that must be generated with the dict input must be then provided as either factory , model_generator or light . Returns True , if asset could be added to the collection. get \u00b6 AssetsManager . get ( tag , * args , ** kwargs ) Return an asset reference by tag . Input arguments tag ( type: str ): Tag of the asset. In case tag is referencing a pcg_gazebo.generators.ModelGroupGenerator , additional inputs to run the engines can be provided using *args and **kwargs . Returns pcg_gazebo.simulation.SimulationModel or pcg_gazebo.simulation.ModelGroup . None , if tag is invalid. set_asset_as_ground_plane \u00b6 AssetsManager . set_asset_as_ground_plane ( tag ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments tag ( type: str ): Name of the model asset from_dict \u00b6 AssetsManager . from_dict ( config ) Read assets from an input dict . The dictionary should have a list of asset descriptions under the tag assets and, if necessary, a list of strings referring to models that must be flagged as ground plane under the tag ground_plane . Input arguments config ( type: data_type , default: data ): Parameter description Returns Description of return values from_yaml \u00b6 AssetsManager . from_yaml ( filename ) Load the assets from a YAML file. Input arguments filename ( type: str ): YAML filename. has_element \u00b6 AssetsManager . has_element ( tag ) Return True if an element for tag exists. Input arguments tag ( type: str ): Tag of the element. CollisionChecker \u00b6 CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. scene \u00b6 trimesh.scene.Scene : Collision check scenario reset_scenario \u00b6 CollisionChecker . reset_scenario () Remove all meshes from collision check scene. reset_to_fixed_model_scenario \u00b6 CollisionChecker . reset_to_fixed_model_scenario () Remove all meshes that were not generated by a fixed-pose engine. add_fixed_model \u00b6 CollisionChecker . add_fixed_model ( model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure add_model \u00b6 CollisionChecker . add_model ( model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure show \u00b6 CollisionChecker . show () Display the current collision check scenario using pyglet . check_collision_with_current_scene \u00b6 CollisionChecker . check_collision_with_current_scene ( model , min_distance = 0.0 ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise. check_for_collisions \u00b6 CollisionChecker . check_for_collisions () Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise. ConstraintsManager \u00b6 ConstraintsManager ( self ) add \u00b6 ConstraintsManager . add ( name , type = None , constraint_obj = None , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created EngineManager \u00b6 EngineManager ( self ) add \u00b6 EngineManager . add ( tag , engine_name = None , models = None , engine_obj = None , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine. from_yaml \u00b6 EngineManager . from_yaml ( filename ) Load the engines from a YAML file. Input arguments filename ( type: str ): YAML filename. ModelGroupGenerator \u00b6 ModelGroupGenerator ( self , name = 'generator' , ** kwargs ) SingletonCollisionChecker \u00b6 SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance() . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. get_instance \u00b6 SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance WorldGenerator \u00b6 WorldGenerator ( self , name = 'default' , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' , ** kwargs ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo.task_manager.GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime. gazebo_proxy \u00b6 pcg_gazebo.task_manager.GazeboProxy : Internal instance of the GazeboProxy world \u00b6 pcg_gazebo.simulation.World : World abstraction instance init_gazebo_proxy \u00b6 WorldGenerator . init_gazebo_proxy ( ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server delete_model \u00b6 WorldGenerator . delete_model ( model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation. from_dict \u00b6 WorldGenerator . from_dict ( config ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, # it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values spawn_model \u00b6 WorldGenerator . spawn_model ( model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo.simulation.SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [0, 0, 0] ): Spawning position wrt reference frame rot ( type: list , default: [0, 0, 0] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned. get_physics_engine \u00b6 WorldGenerator . get_physics_engine ( engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo.simulation.physics.Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo.simulation.physics.Physics object. reset_world \u00b6 WorldGenerator . reset_world ( name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [0, 0, -9.8] ): Gravitational acceleration vector export_world \u00b6 WorldGenerator . export_world ( output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True , models_output_dir = None , overwrite = True , sdf_version = '1.6' ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str plot_results \u00b6 WorldGenerator . plot_results ( fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"pcg_gazebo.generators"},{"location":"reference/generators/#pcg_gazebogenerators","text":"The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints.","title":"pcg_gazebo.generators"},{"location":"reference/generators/#assetsmanager","text":"AssetsManager ( self ) Assets manager containing all valid Gazebo models and model group generators. This collection should be initialized as a singleton object in order to have a single source of model to all instances of engines, model and world generators. The asset types allowed to be added are: pcg_gazebo.simulation.SimulationModel : Description for a model pcg_gazebo.simulation.Light : Description for light sources pcg_gazebo.simulation.ModelGroup : Group of models and light sources pcg_gazebo.generators.ModelGroupGenerator : Dynamic model group generator dict : Input configuration of the creators factory methods for box , sphere , cylinder and mesh models, for an instance of pcg_gazebo.simulation.Light , or an instance of pcg_gazebo.generators.ModelGroupGenerator str : Name of an existing Gazebo model that can be found in the Gazebo resources path","title":"AssetsManager"},{"location":"reference/generators/#ground_planes","text":"list : List of strings with tags of ground plane models","title":"ground_planes"},{"location":"reference/generators/#tags","text":"list : List of strings with all asset tags","title":"tags"},{"location":"reference/generators/#get_instance","text":"AssetsManager . get_instance () Return singleton instance of the AssetsMananger","title":"get_instance"},{"location":"reference/generators/#is_model","text":"AssetsManager . is_model ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.SimulationModel . Input arguments tag ( type: str ): Tag of the asset.","title":"is_model"},{"location":"reference/generators/#is_light","text":"AssetsManager . is_light ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.Light . Input arguments tag ( type: str ): Tag of the asset.","title":"is_light"},{"location":"reference/generators/#is_model_group","text":"AssetsManager . is_model_group ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.simulation.ModelGroup . Input arguments tag ( type: str ): Tag of the asset.","title":"is_model_group"},{"location":"reference/generators/#is_gazebo_model","text":"AssetsManager . is_gazebo_model ( tag ) Return if asset identified by tag is a Gazebo model found in Gazebo's resources path. Input arguments tag ( type: str ): Tag of the asset.","title":"is_gazebo_model"},{"location":"reference/generators/#is_model_group_generator","text":"AssetsManager . is_model_group_generator ( tag ) Return if asset identified by tag is an instance of pcg_gazebo.generators.ModelGroupGenerator . Input arguments tag ( type: str ): Tag of the asset.","title":"is_model_group_generator"},{"location":"reference/generators/#is_ground_plane","text":"AssetsManager . is_ground_plane ( tag ) Return if asset identified by tag is flagged as a ground plane model. Input arguments tag ( type: str ): Tag of the asset.","title":"is_ground_plane"},{"location":"reference/generators/#is_factory_input","text":"AssetsManager . is_factory_input ( tag ) Return if asset identified by tag is a dict containing the inputs for a pcg_gazebo.generators.creators factory method to create a box , sphere , cylinder or mesh model. Input arguments tag ( type: str ): Tag of the asset.","title":"is_factory_input"},{"location":"reference/generators/#add","text":"AssetsManager . add ( description , tag = None , type = None , parameters = None , include_dir = None , overwrite = True ) Add new asset to the collection. Input arguments description ( type: str , dict , pcg_gazebo.simulation.SimulationModel , pcg_gazebo.simulation.Light , pcg_gazebo.simulation.ModelGroup or pcg_gazebo.generators.ModelGroupGenerator ): Model description. tag ( type: str , default: None ): Asset's tag. If None is provided, the input description must have an attribute name which will be used as a tag, otherwise the function returns False . type ( type: str , default: None ): When the provided description is dict , the type of asset that must be generated with the dict input must be then provided as either factory , model_generator or light . Returns True , if asset could be added to the collection.","title":"add"},{"location":"reference/generators/#get","text":"AssetsManager . get ( tag , * args , ** kwargs ) Return an asset reference by tag . Input arguments tag ( type: str ): Tag of the asset. In case tag is referencing a pcg_gazebo.generators.ModelGroupGenerator , additional inputs to run the engines can be provided using *args and **kwargs . Returns pcg_gazebo.simulation.SimulationModel or pcg_gazebo.simulation.ModelGroup . None , if tag is invalid.","title":"get"},{"location":"reference/generators/#set_asset_as_ground_plane","text":"AssetsManager . set_asset_as_ground_plane ( tag ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments tag ( type: str ): Name of the model asset","title":"set_asset_as_ground_plane"},{"location":"reference/generators/#from_dict","text":"AssetsManager . from_dict ( config ) Read assets from an input dict . The dictionary should have a list of asset descriptions under the tag assets and, if necessary, a list of strings referring to models that must be flagged as ground plane under the tag ground_plane . Input arguments config ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"from_dict"},{"location":"reference/generators/#from_yaml","text":"AssetsManager . from_yaml ( filename ) Load the assets from a YAML file. Input arguments filename ( type: str ): YAML filename.","title":"from_yaml"},{"location":"reference/generators/#has_element","text":"AssetsManager . has_element ( tag ) Return True if an element for tag exists. Input arguments tag ( type: str ): Tag of the element.","title":"has_element"},{"location":"reference/generators/#collisionchecker","text":"CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks.","title":"CollisionChecker"},{"location":"reference/generators/#scene","text":"trimesh.scene.Scene : Collision check scenario","title":"scene"},{"location":"reference/generators/#reset_scenario","text":"CollisionChecker . reset_scenario () Remove all meshes from collision check scene.","title":"reset_scenario"},{"location":"reference/generators/#reset_to_fixed_model_scenario","text":"CollisionChecker . reset_to_fixed_model_scenario () Remove all meshes that were not generated by a fixed-pose engine.","title":"reset_to_fixed_model_scenario"},{"location":"reference/generators/#add_fixed_model","text":"CollisionChecker . add_fixed_model ( model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure","title":"add_fixed_model"},{"location":"reference/generators/#add_model","text":"CollisionChecker . add_model ( model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure","title":"add_model"},{"location":"reference/generators/#show","text":"CollisionChecker . show () Display the current collision check scenario using pyglet .","title":"show"},{"location":"reference/generators/#check_collision_with_current_scene","text":"CollisionChecker . check_collision_with_current_scene ( model , min_distance = 0.0 ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise.","title":"check_collision_with_current_scene"},{"location":"reference/generators/#check_for_collisions","text":"CollisionChecker . check_for_collisions () Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise.","title":"check_for_collisions"},{"location":"reference/generators/#constraintsmanager","text":"ConstraintsManager ( self )","title":"ConstraintsManager"},{"location":"reference/generators/#add_1","text":"ConstraintsManager . add ( name , type = None , constraint_obj = None , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created","title":"add"},{"location":"reference/generators/#enginemanager","text":"EngineManager ( self )","title":"EngineManager"},{"location":"reference/generators/#add_2","text":"EngineManager . add ( tag , engine_name = None , models = None , engine_obj = None , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine.","title":"add"},{"location":"reference/generators/#from_yaml_1","text":"EngineManager . from_yaml ( filename ) Load the engines from a YAML file. Input arguments filename ( type: str ): YAML filename.","title":"from_yaml"},{"location":"reference/generators/#modelgroupgenerator","text":"ModelGroupGenerator ( self , name = 'generator' , ** kwargs )","title":"ModelGroupGenerator"},{"location":"reference/generators/#singletoncollisionchecker","text":"SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance() . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks.","title":"SingletonCollisionChecker"},{"location":"reference/generators/#get_instance_1","text":"SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance","title":"get_instance"},{"location":"reference/generators/#worldgenerator","text":"WorldGenerator ( self , name = 'default' , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' , ** kwargs ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo.task_manager.GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime.","title":"WorldGenerator"},{"location":"reference/generators/#gazebo_proxy","text":"pcg_gazebo.task_manager.GazeboProxy : Internal instance of the GazeboProxy","title":"gazebo_proxy"},{"location":"reference/generators/#world","text":"pcg_gazebo.simulation.World : World abstraction instance","title":"world"},{"location":"reference/generators/#init_gazebo_proxy","text":"WorldGenerator . init_gazebo_proxy ( ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server","title":"init_gazebo_proxy"},{"location":"reference/generators/#delete_model","text":"WorldGenerator . delete_model ( model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation.","title":"delete_model"},{"location":"reference/generators/#from_dict_1","text":"WorldGenerator . from_dict ( config ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, # it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values","title":"from_dict"},{"location":"reference/generators/#spawn_model","text":"WorldGenerator . spawn_model ( model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo.simulation.SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [0, 0, 0] ): Spawning position wrt reference frame rot ( type: list , default: [0, 0, 0] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned.","title":"spawn_model"},{"location":"reference/generators/#get_physics_engine","text":"WorldGenerator . get_physics_engine ( engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo.simulation.physics.Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo.simulation.physics.Physics object.","title":"get_physics_engine"},{"location":"reference/generators/#reset_world","text":"WorldGenerator . reset_world ( name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [0, 0, -9.8] ): Gravitational acceleration vector","title":"reset_world"},{"location":"reference/generators/#export_world","text":"WorldGenerator . export_world ( output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True , models_output_dir = None , overwrite = True , sdf_version = '1.6' ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str","title":"export_world"},{"location":"reference/generators/#plot_results","text":"WorldGenerator . plot_results ( fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"plot_results"},{"location":"reference/generators_components/","text":"pcg_gazebo.generators.components \u00b6 HingedDoor \u00b6 HingedDoor ( self , door_mesh_filename = None , width = 0.6 , thickness = 0.04 , height = 2.0 , mass = 10 , set_origin_to_ground = True , fix_to_world = True , hand_convention = 'LH' , max_opening_angle = 1.5707963267948966 , name = 'door' , frame_mesh_filename = None , with_frame = True , frame_width = 0.05 , frame_height = 0.05 , frame_depth = 0.05 ) Walls \u00b6 Walls ( self , height , thickness = 0.1 , geometries = None , model_name = 'wall' , cap_style = 'square' , join_style = 'mitre' )","title":"pcg_gazebo.generators.components"},{"location":"reference/generators_components/#pcg_gazebogeneratorscomponents","text":"","title":"pcg_gazebo.generators.components"},{"location":"reference/generators_components/#hingeddoor","text":"HingedDoor ( self , door_mesh_filename = None , width = 0.6 , thickness = 0.04 , height = 2.0 , mass = 10 , set_origin_to_ground = True , fix_to_world = True , hand_convention = 'LH' , max_opening_angle = 1.5707963267948966 , name = 'door' , frame_mesh_filename = None , with_frame = True , frame_width = 0.05 , frame_height = 0.05 , frame_depth = 0.05 )","title":"HingedDoor"},{"location":"reference/generators_components/#walls","text":"Walls ( self , height , thickness = 0.1 , geometries = None , model_name = 'wall' , cap_style = 'square' , join_style = 'mitre' )","title":"Walls"},{"location":"reference/generators_constraints/","text":"pcg_gazebo.generators.constraints \u00b6 Spatial constraints for the placement of simulation entities into the world. Constraint \u00b6 Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class. TangentConstraint \u00b6 TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented ) apply_constraint \u00b6 TangentConstraint . apply_constraint ( model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference WorkspaceConstraint \u00b6 WorkspaceConstraint ( self , geometry_type = None , frame = 'world' , holes = None , pose = None , ** kwargs ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace generate_geometry \u00b6 WorkspaceConstraint . generate_geometry ( type , ** kwargs ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry get_bounds \u00b6 WorkspaceConstraint . get_bounds () Return the polygon bounds get_random_position \u00b6 WorkspaceConstraint . get_random_position () Return a random position that belongs to the workspace contains_point \u00b6 WorkspaceConstraint . contains_point ( point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy.ndarray ): 2D point contains_polygons \u00b6 WorkspaceConstraint . contains_polygons ( polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely.Polygon ): List of polygons get_geometry \u00b6 WorkspaceConstraint . get_geometry () Return the workspace geometry","title":"pcg_gazebo.generators.constraints"},{"location":"reference/generators_constraints/#pcg_gazebogeneratorsconstraints","text":"Spatial constraints for the placement of simulation entities into the world.","title":"pcg_gazebo.generators.constraints"},{"location":"reference/generators_constraints/#constraint","text":"Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class.","title":"Constraint"},{"location":"reference/generators_constraints/#tangentconstraint","text":"TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented )","title":"TangentConstraint"},{"location":"reference/generators_constraints/#apply_constraint","text":"TangentConstraint . apply_constraint ( model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference","title":"apply_constraint"},{"location":"reference/generators_constraints/#workspaceconstraint","text":"WorkspaceConstraint ( self , geometry_type = None , frame = 'world' , holes = None , pose = None , ** kwargs ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace","title":"WorkspaceConstraint"},{"location":"reference/generators_constraints/#generate_geometry","text":"WorkspaceConstraint . generate_geometry ( type , ** kwargs ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry","title":"generate_geometry"},{"location":"reference/generators_constraints/#get_bounds","text":"WorkspaceConstraint . get_bounds () Return the polygon bounds","title":"get_bounds"},{"location":"reference/generators_constraints/#get_random_position","text":"WorkspaceConstraint . get_random_position () Return a random position that belongs to the workspace","title":"get_random_position"},{"location":"reference/generators_constraints/#contains_point","text":"WorkspaceConstraint . contains_point ( point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy.ndarray ): 2D point","title":"contains_point"},{"location":"reference/generators_constraints/#contains_polygons","text":"WorkspaceConstraint . contains_polygons ( polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely.Polygon ): List of polygons","title":"contains_polygons"},{"location":"reference/generators_constraints/#get_geometry","text":"WorkspaceConstraint . get_geometry () Return the workspace geometry","title":"get_geometry"},{"location":"reference/generators_engines/","text":"pcg_gazebo.generators.engines \u00b6 Pose generator engine definitions that compute the pose of the models according to pre-defined rules. create_engine \u00b6 create_engine ( tag , ** kwargs ) Engine factory that returns the engine according to its LABEL definition. It returns None if the engine name is invalid. Input parameters tag ( type: str ): Name of the engine class kwargs : Inputs for the engine class constructor Engine \u00b6 Engine ( self , assets_manager = None , constraints_manager = None , models = None , constraints = None , collision_checker = None , model_picker = None , as_model_group = False , ** kwargs ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes. label \u00b6 str : Engine name identifier models \u00b6 List of str : List of model name tags regarding the engine's model assets poses \u00b6 dict : List of fixed poses associated with model names. add_local_constraint \u00b6 Engine . add_local_constraint ( model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition get_local_constraints_for_model \u00b6 Engine . get_local_constraints_for_model ( model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned. apply_local_constraints \u00b6 Engine . apply_local_constraints ( model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model instance Returns pcg_gazebo.simulation.SimulationModel : Model with modified pose. add_model \u00b6 Engine . add_model ( model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model set_fixed_pose_model \u00b6 Engine . set_fixed_pose_model ( model ) Set a model as a fixed model in the world to populate the collision checker. Input arguments model ( type: simulation.SimulationModel or simulation.ModelGroup ): Simulation asset. Returns True , if model could be added to list of fixed models. run \u00b6 Engine . run () This function should be implemented by the derived classes. FixedPoseEngine \u00b6 FixedPoseEngine ( self , assets_manager , constraints_manager = None , models = None , poses = None , constraints = None , collision_checker = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses. add_pose \u00b6 FixedPoseEngine . add_pose ( pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses. run \u00b6 FixedPoseEngine . run () Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo.simulation.SimulationModel : Model instances. PatternEngine \u00b6 PatternEngine ( self , assets_manager , constraints_manager = None , models = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], pattern = None , collision_checker = None , ** kwargs ) RandomPoseEngine \u00b6 RandomPoseEngine ( self , assets_manager = None , constraints_manager = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' , collision_checker = None , min_distance = 0.0 ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments assets_manager ( type: pcg_gazebo.generators.AssetsManager ) callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on # workspaces, check the # class definition for # `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793 reset_counter \u00b6 RandomPoseEngine . reset_counter () Reset all model counters. increase_counter \u00b6 RandomPoseEngine . increase_counter ( name ) Increase the counter for a model. Input arguments name ( type: str ): Model name get_num_models \u00b6 RandomPoseEngine . get_num_models ( name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models is_model_in_workspace \u00b6 RandomPoseEngine . is_model_in_workspace ( model ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace get_list_of_footprint_polygons \u00b6 RandomPoseEngine . get_list_of_footprint_polygons ( footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely.geometry.Polygon : List of footprint polygons has_collision \u00b6 RandomPoseEngine . has_collision ( model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Returns bool : True , if any collision is detected run \u00b6 RandomPoseEngine . run () Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo.simulation.SimulationModel","title":"pcg_gazebo.generators.engines"},{"location":"reference/generators_engines/#pcg_gazebogeneratorsengines","text":"Pose generator engine definitions that compute the pose of the models according to pre-defined rules.","title":"pcg_gazebo.generators.engines"},{"location":"reference/generators_engines/#create_engine","text":"create_engine ( tag , ** kwargs ) Engine factory that returns the engine according to its LABEL definition. It returns None if the engine name is invalid. Input parameters tag ( type: str ): Name of the engine class kwargs : Inputs for the engine class constructor","title":"create_engine"},{"location":"reference/generators_engines/#engine","text":"Engine ( self , assets_manager = None , constraints_manager = None , models = None , constraints = None , collision_checker = None , model_picker = None , as_model_group = False , ** kwargs ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes.","title":"Engine"},{"location":"reference/generators_engines/#label","text":"str : Engine name identifier","title":"label"},{"location":"reference/generators_engines/#models","text":"List of str : List of model name tags regarding the engine's model assets","title":"models"},{"location":"reference/generators_engines/#poses","text":"dict : List of fixed poses associated with model names.","title":"poses"},{"location":"reference/generators_engines/#add_local_constraint","text":"Engine . add_local_constraint ( model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition","title":"add_local_constraint"},{"location":"reference/generators_engines/#get_local_constraints_for_model","text":"Engine . get_local_constraints_for_model ( model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned.","title":"get_local_constraints_for_model"},{"location":"reference/generators_engines/#apply_local_constraints","text":"Engine . apply_local_constraints ( model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Model instance Returns pcg_gazebo.simulation.SimulationModel : Model with modified pose.","title":"apply_local_constraints"},{"location":"reference/generators_engines/#add_model","text":"Engine . add_model ( model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model","title":"add_model"},{"location":"reference/generators_engines/#set_fixed_pose_model","text":"Engine . set_fixed_pose_model ( model ) Set a model as a fixed model in the world to populate the collision checker. Input arguments model ( type: simulation.SimulationModel or simulation.ModelGroup ): Simulation asset. Returns True , if model could be added to list of fixed models.","title":"set_fixed_pose_model"},{"location":"reference/generators_engines/#run","text":"Engine . run () This function should be implemented by the derived classes.","title":"run"},{"location":"reference/generators_engines/#fixedposeengine","text":"FixedPoseEngine ( self , assets_manager , constraints_manager = None , models = None , poses = None , constraints = None , collision_checker = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses.","title":"FixedPoseEngine"},{"location":"reference/generators_engines/#add_pose","text":"FixedPoseEngine . add_pose ( pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses.","title":"add_pose"},{"location":"reference/generators_engines/#run_1","text":"FixedPoseEngine . run () Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo.simulation.SimulationModel : Model instances.","title":"run"},{"location":"reference/generators_engines/#patternengine","text":"PatternEngine ( self , assets_manager , constraints_manager = None , models = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], pattern = None , collision_checker = None , ** kwargs )","title":"PatternEngine"},{"location":"reference/generators_engines/#randomposeengine","text":"RandomPoseEngine ( self , assets_manager = None , constraints_manager = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' , collision_checker = None , min_distance = 0.0 ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments assets_manager ( type: pcg_gazebo.generators.AssetsManager ) callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo.constraints.Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on # workspaces, check the # class definition for # `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793","title":"RandomPoseEngine"},{"location":"reference/generators_engines/#reset_counter","text":"RandomPoseEngine . reset_counter () Reset all model counters.","title":"reset_counter"},{"location":"reference/generators_engines/#increase_counter","text":"RandomPoseEngine . increase_counter ( name ) Increase the counter for a model. Input arguments name ( type: str ): Model name","title":"increase_counter"},{"location":"reference/generators_engines/#get_num_models","text":"RandomPoseEngine . get_num_models ( name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models","title":"get_num_models"},{"location":"reference/generators_engines/#is_model_in_workspace","text":"RandomPoseEngine . is_model_in_workspace ( model ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace","title":"is_model_in_workspace"},{"location":"reference/generators_engines/#get_list_of_footprint_polygons","text":"RandomPoseEngine . get_list_of_footprint_polygons ( footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely.geometries.Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely.geometry.Polygon : List of footprint polygons","title":"get_list_of_footprint_polygons"},{"location":"reference/generators_engines/#has_collision","text":"RandomPoseEngine . has_collision ( model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo.simulation.SimulationModel ): Returns bool : True , if any collision is detected","title":"has_collision"},{"location":"reference/generators_engines/#run_2","text":"RandomPoseEngine . run () Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo.simulation.SimulationModel","title":"run"},{"location":"reference/generators_item_pickers/","text":"pcg_gazebo.generators.item_pickers \u00b6 create_picker \u00b6 create_picker ( tag , ** kwargs ) Picker factory that returns the picker according to its LABEL definition. It returns None if the picker name is invalid. Input parameters tag ( type: str ): Name of the picker class kwargs : Inputs for the picker class constructor _Picker \u00b6 _Picker ( self , items = None , max_num = None ) RandomPicker \u00b6 RandomPicker ( self , items = None , max_num = None ) RouletteWheelPicker \u00b6 RouletteWheelPicker ( self , items , max_num , fitness ) SizePicker \u00b6 SizePicker ( self , items = None , max_num = None )","title":"pcg_gazebo.generators.item_pickers"},{"location":"reference/generators_item_pickers/#pcg_gazebogeneratorsitem_pickers","text":"","title":"pcg_gazebo.generators.item_pickers"},{"location":"reference/generators_item_pickers/#create_picker","text":"create_picker ( tag , ** kwargs ) Picker factory that returns the picker according to its LABEL definition. It returns None if the picker name is invalid. Input parameters tag ( type: str ): Name of the picker class kwargs : Inputs for the picker class constructor","title":"create_picker"},{"location":"reference/generators_item_pickers/#_picker","text":"_Picker ( self , items = None , max_num = None )","title":"_Picker"},{"location":"reference/generators_item_pickers/#randompicker","text":"RandomPicker ( self , items = None , max_num = None )","title":"RandomPicker"},{"location":"reference/generators_item_pickers/#roulettewheelpicker","text":"RouletteWheelPicker ( self , items , max_num , fitness )","title":"RouletteWheelPicker"},{"location":"reference/generators_item_pickers/#sizepicker","text":"SizePicker ( self , items = None , max_num = None )","title":"SizePicker"},{"location":"reference/generators_rules/","text":"pcg_gazebo.generators.rules \u00b6 create_rule \u00b6 create_rule ( tag = None , ** kwargs ) Rule factory that returns the engine according to its LABEL definition. It returns None if the engine name is invalid. Input parameters tag ( type: str ): Name of the engine class kwargs : Inputs for the engine class constructor FixedValue \u00b6 FixedValue ( self , dofs = None , value = None , ** kwargs ) FromSet \u00b6 FromSet ( self , dofs = None , values = None ) Random \u00b6 Random ( self , dofs = None , scaling_factor = 1 , offset = 0 ) Rule \u00b6 Rule ( self , dofs = None ) Uniform \u00b6 Uniform ( self , dofs = None , mean = None , min = None , max = None ) WithinWorkspace \u00b6 WithinWorkspace ( self , dofs = None , workspace = None )","title":"pcg_gazebo.generators.rules"},{"location":"reference/generators_rules/#pcg_gazebogeneratorsrules","text":"","title":"pcg_gazebo.generators.rules"},{"location":"reference/generators_rules/#create_rule","text":"create_rule ( tag = None , ** kwargs ) Rule factory that returns the engine according to its LABEL definition. It returns None if the engine name is invalid. Input parameters tag ( type: str ): Name of the engine class kwargs : Inputs for the engine class constructor","title":"create_rule"},{"location":"reference/generators_rules/#fixedvalue","text":"FixedValue ( self , dofs = None , value = None , ** kwargs )","title":"FixedValue"},{"location":"reference/generators_rules/#fromset","text":"FromSet ( self , dofs = None , values = None )","title":"FromSet"},{"location":"reference/generators_rules/#random","text":"Random ( self , dofs = None , scaling_factor = 1 , offset = 0 )","title":"Random"},{"location":"reference/generators_rules/#rule","text":"Rule ( self , dofs = None )","title":"Rule"},{"location":"reference/generators_rules/#uniform","text":"Uniform ( self , dofs = None , mean = None , min = None , max = None )","title":"Uniform"},{"location":"reference/generators_rules/#withinworkspace","text":"WithinWorkspace ( self , dofs = None , workspace = None )","title":"WithinWorkspace"},{"location":"reference/log/","text":"pcg_gazebo.log \u00b6 Global logging methods. update_log_dir \u00b6 update_log_dir ( add_timestamp = True ) Update the output folder for log files. Input arguments add_timestamp ( type: bool , default: True ): Add timestamp to folder name. change_log_root_dir \u00b6 change_log_root_dir ( root_dir , update_log_dir = False , add_timestamp = True ) Change the directory for the output log files. Input arguments root_dir ( type: str ): New output log directory. update_log_dir ( type: bool , default: False ): Update current global path for log directory. add_timestamp ( type: bool , default: True ): Add timestamp to the directory folder name. get_log_dir \u00b6 get_log_dir () Return the current output log directory. create_logger \u00b6 create_logger ( name , log_filename = None , output_dir = None , log_level = 20 ) Create new instance of the logger. Input arguments name ( type: str ): Name of the instance. log_filename ( type: str , default: None ): Name of the log filename, if None use name as filename. output_dir ( type: str , default: data ): Output log directory. If None is provided, use the current log directory PCG_LOG_DIR . log_level ( type: int , default: logging.ERROR ): Log level. Returns Logger object.","title":"pcg_gazebo.log"},{"location":"reference/log/#pcg_gazebolog","text":"Global logging methods.","title":"pcg_gazebo.log"},{"location":"reference/log/#update_log_dir","text":"update_log_dir ( add_timestamp = True ) Update the output folder for log files. Input arguments add_timestamp ( type: bool , default: True ): Add timestamp to folder name.","title":"update_log_dir"},{"location":"reference/log/#change_log_root_dir","text":"change_log_root_dir ( root_dir , update_log_dir = False , add_timestamp = True ) Change the directory for the output log files. Input arguments root_dir ( type: str ): New output log directory. update_log_dir ( type: bool , default: False ): Update current global path for log directory. add_timestamp ( type: bool , default: True ): Add timestamp to the directory folder name.","title":"change_log_root_dir"},{"location":"reference/log/#get_log_dir","text":"get_log_dir () Return the current output log directory.","title":"get_log_dir"},{"location":"reference/log/#create_logger","text":"create_logger ( name , log_filename = None , output_dir = None , log_level = 20 ) Create new instance of the logger. Input arguments name ( type: str ): Name of the instance. log_filename ( type: str , default: None ): Name of the log filename, if None use name as filename. output_dir ( type: str , default: data ): Output log directory. If None is provided, use the current log directory PCG_LOG_DIR . log_level ( type: int , default: logging.ERROR ): Log level. Returns Logger object.","title":"create_logger"},{"location":"reference/parsers/","text":"pcg_gazebo.parsers \u00b6 Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications parse_sdf \u00b6 parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_urdf \u00b6 parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_sdf_config \u00b6 parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object. parse_xml \u00b6 parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections.OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys. parse_xml_str \u00b6 parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections.OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys. parse_xml_dict \u00b6 parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections.OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections.OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo.parsers.types.XMLBase object. convert_to_dict \u00b6 convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo.parsers.types.XMLBase . Input arguments xml_dict ( type: collections.OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary. convert_from_string \u00b6 convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str . sdf2urdf \u00b6 sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid SDF element Returns pcg_gazebo.parsers.types.XMLBase as an URDF element. urdf2sdf \u00b6 urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid URDF element Returns pcg_gazebo.parsers.types.XMLBase as a SDF element.","title":"pcg_gazebo.parsers"},{"location":"reference/parsers/#pcg_gazeboparsers","text":"Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications","title":"pcg_gazebo.parsers"},{"location":"reference/parsers/#parse_sdf","text":"parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_sdf"},{"location":"reference/parsers/#parse_urdf","text":"parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_urdf"},{"location":"reference/parsers/#parse_sdf_config","text":"parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_sdf_config"},{"location":"reference/parsers/#parse_xml","text":"parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections.OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys.","title":"parse_xml"},{"location":"reference/parsers/#parse_xml_str","text":"parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections.OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections.OrderedDict : Dictionary where the XML tags are the keys.","title":"parse_xml_str"},{"location":"reference/parsers/#parse_xml_dict","text":"parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections.OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections.OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo.parsers.types.XMLBase object.","title":"parse_xml_dict"},{"location":"reference/parsers/#convert_to_dict","text":"convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo.parsers.types.XMLBase . Input arguments xml_dict ( type: collections.OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary.","title":"convert_to_dict"},{"location":"reference/parsers/#convert_from_string","text":"convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str .","title":"convert_from_string"},{"location":"reference/parsers/#sdf2urdf","text":"sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid SDF element Returns pcg_gazebo.parsers.types.XMLBase as an URDF element.","title":"sdf2urdf"},{"location":"reference/parsers/#urdf2sdf","text":"urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo.parsers.types.XMLBase ): Valid URDF element Returns pcg_gazebo.parsers.types.XMLBase as a SDF element.","title":"urdf2sdf"},{"location":"reference/parsers_gazebo/","text":"pcg_gazebo.parsers.gazebo \u00b6 Kd \u00b6 Kd ( self , default = 1 ) Kp \u00b6 Kp ( self , default = 1000000000000.0 ) Material \u00b6 Material ( self , default = 'none' ) MaxContacts \u00b6 MaxContacts ( self , default = 20 ) MaxVel \u00b6 MaxVel ( self , default = 0.01 ) MinDepth \u00b6 MinDepth ( self , default = 0 ) Mu1 \u00b6 Mu1 ( self , default = 1 ) Mu2 \u00b6 Mu2 ( self , default = 1 ) ProvideFeedback \u00b6 ProvideFeedback ( self , default = False ) SelfCollide \u00b6 SelfCollide ( self , default = False ) StopCFM \u00b6 StopCFM ( self , default = 0 ) StopERP \u00b6 StopERP ( self , default = 0.2 )","title":"pcg_gazebo.parsers.gazebo"},{"location":"reference/parsers_gazebo/#pcg_gazeboparsersgazebo","text":"","title":"pcg_gazebo.parsers.gazebo"},{"location":"reference/parsers_gazebo/#kd","text":"Kd ( self , default = 1 )","title":"Kd"},{"location":"reference/parsers_gazebo/#kp","text":"Kp ( self , default = 1000000000000.0 )","title":"Kp"},{"location":"reference/parsers_gazebo/#material","text":"Material ( self , default = 'none' )","title":"Material"},{"location":"reference/parsers_gazebo/#maxcontacts","text":"MaxContacts ( self , default = 20 )","title":"MaxContacts"},{"location":"reference/parsers_gazebo/#maxvel","text":"MaxVel ( self , default = 0.01 )","title":"MaxVel"},{"location":"reference/parsers_gazebo/#mindepth","text":"MinDepth ( self , default = 0 )","title":"MinDepth"},{"location":"reference/parsers_gazebo/#mu1","text":"Mu1 ( self , default = 1 )","title":"Mu1"},{"location":"reference/parsers_gazebo/#mu2","text":"Mu2 ( self , default = 1 )","title":"Mu2"},{"location":"reference/parsers_gazebo/#providefeedback","text":"ProvideFeedback ( self , default = False )","title":"ProvideFeedback"},{"location":"reference/parsers_gazebo/#selfcollide","text":"SelfCollide ( self , default = False )","title":"SelfCollide"},{"location":"reference/parsers_gazebo/#stopcfm","text":"StopCFM ( self , default = 0 )","title":"StopCFM"},{"location":"reference/parsers_gazebo/#stoperp","text":"StopERP ( self , default = 0.2 )","title":"StopERP"},{"location":"reference/parsers_sdf/","text":"pcg_gazebo.parsers.sdf \u00b6 Accel \u00b6 Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1.4 Source <accel> (SDF 1.4) bias_mean \u00b6 Return the bias mean value SDF element, to read the value use obj.bias_mean.value bias_stddev \u00b6 Return the bias standard deviation value SDF element, to read the value use obj.bias_stddev.value mean \u00b6 Return the mean value SDF element, to read the value use obj.mean.value stddev \u00b6 Return the standard deviation value SDF element, to read the value use obj.stddev.value Accuracy \u00b6 Accuracy ( self , default = 0.001 ) Actor \u00b6 Actor ( self ) AllowAutoDisable \u00b6 AllowAutoDisable ( self , default = False ) Altimeter \u00b6 Altimeter ( self ) AlwaysOn \u00b6 AlwaysOn ( self , default = False ) Ambient \u00b6 Ambient ( self , default = [ 0 , 0 , 0 , 1 ]) AngularVelocity \u00b6 AngularVelocity ( self ) Angular \u00b6 Angular ( self , default = 0 ) Animation \u00b6 Animation ( self ) Attenuation \u00b6 Attenuation ( self ) AutoStart \u00b6 AutoStart ( self , default = True ) Axis \u00b6 Axis ( self ) Axis2 \u00b6 Axis2 ( self ) Background \u00b6 Background ( self , default = [ 0 , 0 , 0 , 1 ]) BiasMean \u00b6 BiasMean ( self , default = 0 ) BiasStdDev \u00b6 BiasStdDev ( self , default = 0 ) Bounce \u00b6 Bounce ( self ) Box \u00b6 Box ( self ) Bullet \u00b6 Bullet ( self , mode = 'physics' ) CFMDamping \u00b6 CFMDamping ( self , default = False ) CFM \u00b6 CFM ( self , default = 0 ) Camera \u00b6 Camera ( self , mode = 'sensor' ) CastShadows \u00b6 CastShadows ( self , default = True ) CategoryBitmask \u00b6 CategoryBitmask ( self , default = 65535 ) Center \u00b6 Center ( self , default = False ) Child \u00b6 Child ( self , default = 'none' ) Clip \u00b6 Clip ( self ) Clouds \u00b6 Clouds ( self ) Coefficient \u00b6 Coefficient ( self , default = 1 ) CollideBitmask \u00b6 CollideBitmask ( self , default = 65535 ) CollideWithoutContact \u00b6 CollideWithoutContact ( self , default = False ) CollideWithoutContactBitmask \u00b6 CollideWithoutContactBitmask ( self , default = True ) Collision \u00b6 Collision ( self ) Color \u00b6 Color ( self , default = [ 1 , 1 , 1 , 1 ]) Constant \u00b6 Constant ( self , default = 0 ) Constraints \u00b6 Constraints ( self , engine = 'ode' ) Contact \u00b6 Contact ( self , mode = 'simbody' ) ContactMaxCorrectingVel \u00b6 ContactMaxCorrectingVel ( self , default = 100 ) ContactSurfaceLayer \u00b6 ContactSurfaceLayer ( self , default = 0.001 ) Cylinder \u00b6 Cylinder ( self ) Damping \u00b6 Damping ( self , default = 0 ) DelayStart \u00b6 DelayStart ( self , default = 0 ) Density \u00b6 Density ( self , default = 0 ) DepthCamera \u00b6 DepthCamera ( self ) Diffuse \u00b6 Diffuse ( self , default = [ 0 , 0 , 0 , 1 ]) Direction \u00b6 Direction ( self , default = [ 0 , 0 , - 1 ]) Dissipation \u00b6 Dissipation ( self , default = 100 ) Distortion \u00b6 Distortion ( self ) DynamicFriction \u00b6 DynamicFriction ( self , default = 0.9 ) Dynamics \u00b6 Dynamics ( self ) ERP \u00b6 ERP ( self , default = 0.2 ) Effort \u00b6 Effort ( self , default =- 1 ) ElasticModulus \u00b6 ElasticModulus ( self , default =- 1 ) Emissive \u00b6 Emissive ( self , size = 4 ) Empty \u00b6 Empty ( self ) EnableWind \u00b6 EnableWind ( self , default = False ) End \u00b6 End ( self , default = 0 ) FDir1 \u00b6 FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector FallOff \u00b6 FallOff ( self , default = 0 ) Far \u00b6 Far ( self , default = 0 ) Filename \u00b6 Filename ( self , default = 'none' ) Fog \u00b6 Fog ( self , mode = '' ) ForceTorque \u00b6 ForceTorque ( self ) Format \u00b6 Format ( self , default = 'R8G8B8' ) Frame \u00b6 Frame ( self , default = '' ) Friction \u00b6 Friction ( self , mode = 'scalar' , default = 1 , min_value = 0 ) Configuration of the surface friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Friction2 \u00b6 Friction2 ( self , default = 1 ) FrictionModel \u00b6 FrictionModel ( self ) GUI \u00b6 GUI ( self ) Geometry \u00b6 Geometry ( self , mode = 'empty' ) Granularity \u00b6 Granularity ( self , default = 1 ) Gravity \u00b6 Gravity ( self , default = True ) Grid \u00b6 Grid ( self , default = True ) Height \u00b6 Height ( self , default = 1 ) Horizontal \u00b6 Horizontal ( self ) HorizontalFOV \u00b6 HorizontalFOV ( self , default = 1.047 ) Humidity \u00b6 Humidity ( self , default = 0.5 ) IMU \u00b6 IMU ( self ) IXX \u00b6 IXX ( self , default = 0 ) IXY \u00b6 IXY ( self , default = 0 ) IXZ \u00b6 IXZ ( self , default = 0 ) IYY \u00b6 IYY ( self , default = 0 ) IYZ \u00b6 IYZ ( self , default = 0 ) IZZ \u00b6 IZZ ( self , default = 0 ) Image \u00b6 Image ( self , mode = 'geometry' ) Include \u00b6 Include ( self ) Inertia \u00b6 Inertia ( self ) Inertial \u00b6 Inertial ( self ) InheritYaw \u00b6 InheritYaw ( self , default = False ) InitialPosition \u00b6 InitialPosition ( self , default = 0 ) InnerAngle \u00b6 InnerAngle ( self , default = 0 ) InterpolateX \u00b6 InterpolateX ( self , default = False ) Iters \u00b6 Iters ( self , default = 50 ) Joint \u00b6 Joint ( self ) K1 \u00b6 K1 ( self , default = 0 ) K2 \u00b6 K2 ( self , default = 0 ) K3 \u00b6 K3 ( self , default = 0 ) Kd \u00b6 Kd ( self , default = 1 ) Kinematic \u00b6 Kinematic ( self , default = False ) Kp \u00b6 Kp ( self , default = 1000000000000.0 ) LaserRetro \u00b6 LaserRetro ( self , default = 0 ) Length \u00b6 Length ( self ) Light \u00b6 Light ( self ) Lighting \u00b6 Lighting ( self , default = False ) Limit \u00b6 Limit ( self , mode = 'axis' ) Linear \u00b6 Linear ( self , default = 0 , min_value = None , max_value = None ) LinearAcceleration \u00b6 LinearAcceleration ( self ) Link \u00b6 Link ( self ) Localization \u00b6 Localization ( self , default = 'CUSTOM' ) Loop \u00b6 Loop ( self , default = False ) Lower \u00b6 Lower ( self , default =- 1e+16 ) Mass \u00b6 Mass ( self ) Material \u00b6 Material ( self ) Max \u00b6 Max ( self , default = 0 ) MaxAngle \u00b6 MaxAngle ( self , default = 0 ) MaxContacts \u00b6 MaxContacts ( self , default = 20 ) MaxDist \u00b6 MaxDist ( self , default = 0 ) MaxStepSize \u00b6 MaxStepSize ( self , default = 0.001 ) MaxTransientVelocity \u00b6 MaxTransientVelocity ( self , default = 0.01 ) MaxVel \u00b6 MaxVel ( self , default = 0.01 ) Mean \u00b6 Mean ( self ) MeanSize \u00b6 MeanSize ( self , default = 0 ) MeasureDirection \u00b6 MeasureDirection ( self , default = 'child_to_parent' ) Mesh \u00b6 Mesh ( self ) Min \u00b6 Min ( self , default = 0 ) MinAngle \u00b6 MinAngle ( self , default = 0 ) MinDepth \u00b6 MinDepth ( self , default = 0 ) MinDist \u00b6 MinDist ( self , default = 0 ) MinStepSize \u00b6 MinStepSize ( self , default = 0.0001 ) Model \u00b6 Model ( self ) Mu \u00b6 Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Mu2 \u00b6 Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction MustBeLoopJoint \u00b6 MustBeLoopJoint ( self , default = False ) Name \u00b6 Name ( self , default = 'none' ) Near \u00b6 Near ( self , default = 0 ) Noise \u00b6 Noise ( self , type = 'none' , use_type_as = 'attribute' ) Normal \u00b6 Normal ( self ) NormalMap \u00b6 NormalMap ( self , default = '' ) ODE \u00b6 ODE ( self , mode = 'physics' ) OrientationReferenceFrame \u00b6 OrientationReferenceFrame ( self ) OriginVisual \u00b6 OriginVisual ( self , default = True ) OuterAngle \u00b6 OuterAngle ( self , default = 0 ) Output \u00b6 Output ( self , default = 'depths' ) OverrideImpactCaptureVelocity \u00b6 OverrideImpactCaptureVelocity ( self , default = 0.001 ) OverrideStictionTransitionVelocity \u00b6 OverrideStictionTransitionVelocity ( self , default = 0.9 ) P1 \u00b6 P1 ( self , default = 0 ) P2 \u00b6 P2 ( self , default = 0 ) Parent \u00b6 Parent ( self , default = 'parent' ) PatchRadius \u00b6 PatchRadius ( self , default = 0 ) Path \u00b6 Path ( self , default = '__default__' ) Physics \u00b6 Physics ( self , mode = 'ode' ) Plane \u00b6 Plane ( self ) PlasticCoefRestitution \u00b6 PlasticCoefRestitution ( self , default = 0.5 ) PlasticImpactVelocity \u00b6 PlasticImpactVelocity ( self , default = 0.5 ) Plugin \u00b6 Plugin ( self , default = {}) Point \u00b6 Point ( self , vec_length = 2 ) PoissonsRatio \u00b6 PoissonsRatio ( self , default = 0.3 ) Polyline \u00b6 Polyline ( self ) Pose \u00b6 Pose ( self ) PreConIters \u00b6 PreConIters ( self , default = 0 ) Precision \u00b6 Precision ( self ) ProvideFeedback \u00b6 ProvideFeedback ( self , default = False ) Quadratic \u00b6 Quadratic ( self , default = 0 ) Radius \u00b6 Radius ( self , default = 0 ) Range \u00b6 Range ( self ) Rate \u00b6 Rate ( self , type = 'none' ) Ray \u00b6 Ray ( self ) RealTimeFactor \u00b6 RealTimeFactor ( self , default = 1 ) RealTimeUpdateRate \u00b6 RealTimeUpdateRate ( self , default = 1 ) Resolution \u00b6 Resolution ( self , default = 0 ) RestitutionCoefficient \u00b6 RestitutionCoefficient ( self , default = 0 ) RollingFriction \u00b6 RollingFriction ( self , default = 1 ) SDF \u00b6 SDF ( self , mode = 'world' ) Samples \u00b6 Samples ( self , default = 640 ) Save \u00b6 Save ( self ) Scale \u00b6 Scale ( self , size = 3 ) Scan \u00b6 Scan ( self ) Scene \u00b6 Scene ( self ) Script \u00b6 Script ( self , mode = 'material' ) SelfCollide \u00b6 SelfCollide ( self , default = False ) Sensor \u00b6 Sensor ( self , mode = 'altimeter' ) Shader \u00b6 Shader ( self ) Shadows \u00b6 Shadows ( self , default = True ) Simbody \u00b6 Simbody ( self , mode = 'physics' ) Size \u00b6 Size ( self , vec_length = 3 ) Skin \u00b6 Skin ( self ) Sky \u00b6 Sky ( self ) Slip \u00b6 Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip1 \u00b6 Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip2 \u00b6 Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient SoftCFM \u00b6 SoftCFM ( self , default = 0 ) SoftERP \u00b6 SoftERP ( self , default = 0.2 ) Solver \u00b6 Solver ( self , engine = 'ode' ) Sor \u00b6 Sor ( self , default = 1.3 ) Specular \u00b6 Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ]) Speed \u00b6 Speed ( self , default = 0.6 ) Sphere \u00b6 Sphere ( self ) SplitImpulse \u00b6 SplitImpulse ( self , default = True ) SplitImpulsePenetrationThreshold \u00b6 SplitImpulsePenetrationThreshold ( self , default =- 0.01 ) Spot \u00b6 Spot ( self ) SpringReference \u00b6 SpringReference ( self , default = 0 ) SpringStiffness \u00b6 SpringStiffness ( self , default = 0 ) Start \u00b6 Start ( self , default = 0 ) Static \u00b6 Static ( self , default = False ) StaticFriction \u00b6 StaticFriction ( self , default = 0.9 ) StdDev \u00b6 StdDev ( self ) Stiffness \u00b6 Stiffness ( self , default = 100000000.0 ) SubMesh \u00b6 SubMesh ( self ) Sunrise \u00b6 Sunrise ( self , default = 0 ) Sunset \u00b6 Sunset ( self , default = 0 ) Surface \u00b6 Surface ( self ) SurfaceRadius \u00b6 SurfaceRadius ( self , default = 0 ) Threshold \u00b6 Threshold ( self , default = 0 ) Time \u00b6 Time ( self , default = 0 ) Topic \u00b6 Topic ( self , default = 'none' ) Torsional \u00b6 Torsional ( self ) TrackVisual \u00b6 TrackVisual ( self ) Trajectory \u00b6 Trajectory ( self ) Transparency \u00b6 Transparency ( self , default = 0 ) Type \u00b6 Type ( self , default = '' ) URDF \u00b6 URDF ( self , mode = 'model' ) URI \u00b6 URI ( self , default = '' ) UpdateRate \u00b6 UpdateRate ( self , default = 0 ) Upper \u00b6 Upper ( self , default = 1e+16 ) UseDynamicMOIRescaling \u00b6 UseDynamicMOIRescaling ( self , default = False ) UseModelFrame \u00b6 UseModelFrame ( self , default = False ) UseParentModelFrame \u00b6 UseParentModelFrame ( self , default = False ) UsePatchRadius \u00b6 UsePatchRadius ( self , default = True ) Velocity \u00b6 Velocity ( self , default =- 1 ) Vertical \u00b6 Vertical ( self ) VerticalPosition \u00b6 VerticalPosition ( self ) VerticalVelocity \u00b6 VerticalVelocity ( self ) ViewController \u00b6 ViewController ( self , default = 'orbit' ) ViscousFriction \u00b6 ViscousFriction ( self , default = 0 ) Visual \u00b6 Visual ( self ) Visualize \u00b6 Visualize ( self , default = False ) Waypoint \u00b6 Waypoint ( self ) Width \u00b6 Width ( self , default = 320 ) World \u00b6 World ( self ) X \u00b6 X ( self ) XYZ \u00b6 XYZ ( self , default = [ 0 , 0 , 1 ]) Y \u00b6 Y ( self ) Z \u00b6 Z ( self )","title":"pcg_gazebo.parsers.sdf"},{"location":"reference/parsers_sdf/#pcg_gazeboparserssdf","text":"","title":"pcg_gazebo.parsers.sdf"},{"location":"reference/parsers_sdf/#accel","text":"Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1.4 Source <accel> (SDF 1.4)","title":"Accel"},{"location":"reference/parsers_sdf/#bias_mean","text":"Return the bias mean value SDF element, to read the value use obj.bias_mean.value","title":"bias_mean"},{"location":"reference/parsers_sdf/#bias_stddev","text":"Return the bias standard deviation value SDF element, to read the value use obj.bias_stddev.value","title":"bias_stddev"},{"location":"reference/parsers_sdf/#mean","text":"Return the mean value SDF element, to read the value use obj.mean.value","title":"mean"},{"location":"reference/parsers_sdf/#stddev","text":"Return the standard deviation value SDF element, to read the value use obj.stddev.value","title":"stddev"},{"location":"reference/parsers_sdf/#accuracy","text":"Accuracy ( self , default = 0.001 )","title":"Accuracy"},{"location":"reference/parsers_sdf/#actor","text":"Actor ( self )","title":"Actor"},{"location":"reference/parsers_sdf/#allowautodisable","text":"AllowAutoDisable ( self , default = False )","title":"AllowAutoDisable"},{"location":"reference/parsers_sdf/#altimeter","text":"Altimeter ( self )","title":"Altimeter"},{"location":"reference/parsers_sdf/#alwayson","text":"AlwaysOn ( self , default = False )","title":"AlwaysOn"},{"location":"reference/parsers_sdf/#ambient","text":"Ambient ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Ambient"},{"location":"reference/parsers_sdf/#angularvelocity","text":"AngularVelocity ( self )","title":"AngularVelocity"},{"location":"reference/parsers_sdf/#angular","text":"Angular ( self , default = 0 )","title":"Angular"},{"location":"reference/parsers_sdf/#animation","text":"Animation ( self )","title":"Animation"},{"location":"reference/parsers_sdf/#attenuation","text":"Attenuation ( self )","title":"Attenuation"},{"location":"reference/parsers_sdf/#autostart","text":"AutoStart ( self , default = True )","title":"AutoStart"},{"location":"reference/parsers_sdf/#axis","text":"Axis ( self )","title":"Axis"},{"location":"reference/parsers_sdf/#axis2","text":"Axis2 ( self )","title":"Axis2"},{"location":"reference/parsers_sdf/#background","text":"Background ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Background"},{"location":"reference/parsers_sdf/#biasmean","text":"BiasMean ( self , default = 0 )","title":"BiasMean"},{"location":"reference/parsers_sdf/#biasstddev","text":"BiasStdDev ( self , default = 0 )","title":"BiasStdDev"},{"location":"reference/parsers_sdf/#bounce","text":"Bounce ( self )","title":"Bounce"},{"location":"reference/parsers_sdf/#box","text":"Box ( self )","title":"Box"},{"location":"reference/parsers_sdf/#bullet","text":"Bullet ( self , mode = 'physics' )","title":"Bullet"},{"location":"reference/parsers_sdf/#cfmdamping","text":"CFMDamping ( self , default = False )","title":"CFMDamping"},{"location":"reference/parsers_sdf/#cfm","text":"CFM ( self , default = 0 )","title":"CFM"},{"location":"reference/parsers_sdf/#camera","text":"Camera ( self , mode = 'sensor' )","title":"Camera"},{"location":"reference/parsers_sdf/#castshadows","text":"CastShadows ( self , default = True )","title":"CastShadows"},{"location":"reference/parsers_sdf/#categorybitmask","text":"CategoryBitmask ( self , default = 65535 )","title":"CategoryBitmask"},{"location":"reference/parsers_sdf/#center","text":"Center ( self , default = False )","title":"Center"},{"location":"reference/parsers_sdf/#child","text":"Child ( self , default = 'none' )","title":"Child"},{"location":"reference/parsers_sdf/#clip","text":"Clip ( self )","title":"Clip"},{"location":"reference/parsers_sdf/#clouds","text":"Clouds ( self )","title":"Clouds"},{"location":"reference/parsers_sdf/#coefficient","text":"Coefficient ( self , default = 1 )","title":"Coefficient"},{"location":"reference/parsers_sdf/#collidebitmask","text":"CollideBitmask ( self , default = 65535 )","title":"CollideBitmask"},{"location":"reference/parsers_sdf/#collidewithoutcontact","text":"CollideWithoutContact ( self , default = False )","title":"CollideWithoutContact"},{"location":"reference/parsers_sdf/#collidewithoutcontactbitmask","text":"CollideWithoutContactBitmask ( self , default = True )","title":"CollideWithoutContactBitmask"},{"location":"reference/parsers_sdf/#collision","text":"Collision ( self )","title":"Collision"},{"location":"reference/parsers_sdf/#color","text":"Color ( self , default = [ 1 , 1 , 1 , 1 ])","title":"Color"},{"location":"reference/parsers_sdf/#constant","text":"Constant ( self , default = 0 )","title":"Constant"},{"location":"reference/parsers_sdf/#constraints","text":"Constraints ( self , engine = 'ode' )","title":"Constraints"},{"location":"reference/parsers_sdf/#contact","text":"Contact ( self , mode = 'simbody' )","title":"Contact"},{"location":"reference/parsers_sdf/#contactmaxcorrectingvel","text":"ContactMaxCorrectingVel ( self , default = 100 )","title":"ContactMaxCorrectingVel"},{"location":"reference/parsers_sdf/#contactsurfacelayer","text":"ContactSurfaceLayer ( self , default = 0.001 )","title":"ContactSurfaceLayer"},{"location":"reference/parsers_sdf/#cylinder","text":"Cylinder ( self )","title":"Cylinder"},{"location":"reference/parsers_sdf/#damping","text":"Damping ( self , default = 0 )","title":"Damping"},{"location":"reference/parsers_sdf/#delaystart","text":"DelayStart ( self , default = 0 )","title":"DelayStart"},{"location":"reference/parsers_sdf/#density","text":"Density ( self , default = 0 )","title":"Density"},{"location":"reference/parsers_sdf/#depthcamera","text":"DepthCamera ( self )","title":"DepthCamera"},{"location":"reference/parsers_sdf/#diffuse","text":"Diffuse ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Diffuse"},{"location":"reference/parsers_sdf/#direction","text":"Direction ( self , default = [ 0 , 0 , - 1 ])","title":"Direction"},{"location":"reference/parsers_sdf/#dissipation","text":"Dissipation ( self , default = 100 )","title":"Dissipation"},{"location":"reference/parsers_sdf/#distortion","text":"Distortion ( self )","title":"Distortion"},{"location":"reference/parsers_sdf/#dynamicfriction","text":"DynamicFriction ( self , default = 0.9 )","title":"DynamicFriction"},{"location":"reference/parsers_sdf/#dynamics","text":"Dynamics ( self )","title":"Dynamics"},{"location":"reference/parsers_sdf/#erp","text":"ERP ( self , default = 0.2 )","title":"ERP"},{"location":"reference/parsers_sdf/#effort","text":"Effort ( self , default =- 1 )","title":"Effort"},{"location":"reference/parsers_sdf/#elasticmodulus","text":"ElasticModulus ( self , default =- 1 )","title":"ElasticModulus"},{"location":"reference/parsers_sdf/#emissive","text":"Emissive ( self , size = 4 )","title":"Emissive"},{"location":"reference/parsers_sdf/#empty","text":"Empty ( self )","title":"Empty"},{"location":"reference/parsers_sdf/#enablewind","text":"EnableWind ( self , default = False )","title":"EnableWind"},{"location":"reference/parsers_sdf/#end","text":"End ( self , default = 0 )","title":"End"},{"location":"reference/parsers_sdf/#fdir1","text":"FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector","title":"FDir1"},{"location":"reference/parsers_sdf/#falloff","text":"FallOff ( self , default = 0 )","title":"FallOff"},{"location":"reference/parsers_sdf/#far","text":"Far ( self , default = 0 )","title":"Far"},{"location":"reference/parsers_sdf/#filename","text":"Filename ( self , default = 'none' )","title":"Filename"},{"location":"reference/parsers_sdf/#fog","text":"Fog ( self , mode = '' )","title":"Fog"},{"location":"reference/parsers_sdf/#forcetorque","text":"ForceTorque ( self )","title":"ForceTorque"},{"location":"reference/parsers_sdf/#format","text":"Format ( self , default = 'R8G8B8' )","title":"Format"},{"location":"reference/parsers_sdf/#frame","text":"Frame ( self , default = '' )","title":"Frame"},{"location":"reference/parsers_sdf/#friction","text":"Friction ( self , mode = 'scalar' , default = 1 , min_value = 0 ) Configuration of the surface friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Friction"},{"location":"reference/parsers_sdf/#friction2","text":"Friction2 ( self , default = 1 )","title":"Friction2"},{"location":"reference/parsers_sdf/#frictionmodel","text":"FrictionModel ( self )","title":"FrictionModel"},{"location":"reference/parsers_sdf/#gui","text":"GUI ( self )","title":"GUI"},{"location":"reference/parsers_sdf/#geometry","text":"Geometry ( self , mode = 'empty' )","title":"Geometry"},{"location":"reference/parsers_sdf/#granularity","text":"Granularity ( self , default = 1 )","title":"Granularity"},{"location":"reference/parsers_sdf/#gravity","text":"Gravity ( self , default = True )","title":"Gravity"},{"location":"reference/parsers_sdf/#grid","text":"Grid ( self , default = True )","title":"Grid"},{"location":"reference/parsers_sdf/#height","text":"Height ( self , default = 1 )","title":"Height"},{"location":"reference/parsers_sdf/#horizontal","text":"Horizontal ( self )","title":"Horizontal"},{"location":"reference/parsers_sdf/#horizontalfov","text":"HorizontalFOV ( self , default = 1.047 )","title":"HorizontalFOV"},{"location":"reference/parsers_sdf/#humidity","text":"Humidity ( self , default = 0.5 )","title":"Humidity"},{"location":"reference/parsers_sdf/#imu","text":"IMU ( self )","title":"IMU"},{"location":"reference/parsers_sdf/#ixx","text":"IXX ( self , default = 0 )","title":"IXX"},{"location":"reference/parsers_sdf/#ixy","text":"IXY ( self , default = 0 )","title":"IXY"},{"location":"reference/parsers_sdf/#ixz","text":"IXZ ( self , default = 0 )","title":"IXZ"},{"location":"reference/parsers_sdf/#iyy","text":"IYY ( self , default = 0 )","title":"IYY"},{"location":"reference/parsers_sdf/#iyz","text":"IYZ ( self , default = 0 )","title":"IYZ"},{"location":"reference/parsers_sdf/#izz","text":"IZZ ( self , default = 0 )","title":"IZZ"},{"location":"reference/parsers_sdf/#image","text":"Image ( self , mode = 'geometry' )","title":"Image"},{"location":"reference/parsers_sdf/#include","text":"Include ( self )","title":"Include"},{"location":"reference/parsers_sdf/#inertia","text":"Inertia ( self )","title":"Inertia"},{"location":"reference/parsers_sdf/#inertial","text":"Inertial ( self )","title":"Inertial"},{"location":"reference/parsers_sdf/#inherityaw","text":"InheritYaw ( self , default = False )","title":"InheritYaw"},{"location":"reference/parsers_sdf/#initialposition","text":"InitialPosition ( self , default = 0 )","title":"InitialPosition"},{"location":"reference/parsers_sdf/#innerangle","text":"InnerAngle ( self , default = 0 )","title":"InnerAngle"},{"location":"reference/parsers_sdf/#interpolatex","text":"InterpolateX ( self , default = False )","title":"InterpolateX"},{"location":"reference/parsers_sdf/#iters","text":"Iters ( self , default = 50 )","title":"Iters"},{"location":"reference/parsers_sdf/#joint","text":"Joint ( self )","title":"Joint"},{"location":"reference/parsers_sdf/#k1","text":"K1 ( self , default = 0 )","title":"K1"},{"location":"reference/parsers_sdf/#k2","text":"K2 ( self , default = 0 )","title":"K2"},{"location":"reference/parsers_sdf/#k3","text":"K3 ( self , default = 0 )","title":"K3"},{"location":"reference/parsers_sdf/#kd","text":"Kd ( self , default = 1 )","title":"Kd"},{"location":"reference/parsers_sdf/#kinematic","text":"Kinematic ( self , default = False )","title":"Kinematic"},{"location":"reference/parsers_sdf/#kp","text":"Kp ( self , default = 1000000000000.0 )","title":"Kp"},{"location":"reference/parsers_sdf/#laserretro","text":"LaserRetro ( self , default = 0 )","title":"LaserRetro"},{"location":"reference/parsers_sdf/#length","text":"Length ( self )","title":"Length"},{"location":"reference/parsers_sdf/#light","text":"Light ( self )","title":"Light"},{"location":"reference/parsers_sdf/#lighting","text":"Lighting ( self , default = False )","title":"Lighting"},{"location":"reference/parsers_sdf/#limit","text":"Limit ( self , mode = 'axis' )","title":"Limit"},{"location":"reference/parsers_sdf/#linear","text":"Linear ( self , default = 0 , min_value = None , max_value = None )","title":"Linear"},{"location":"reference/parsers_sdf/#linearacceleration","text":"LinearAcceleration ( self )","title":"LinearAcceleration"},{"location":"reference/parsers_sdf/#link","text":"Link ( self )","title":"Link"},{"location":"reference/parsers_sdf/#localization","text":"Localization ( self , default = 'CUSTOM' )","title":"Localization"},{"location":"reference/parsers_sdf/#loop","text":"Loop ( self , default = False )","title":"Loop"},{"location":"reference/parsers_sdf/#lower","text":"Lower ( self , default =- 1e+16 )","title":"Lower"},{"location":"reference/parsers_sdf/#mass","text":"Mass ( self )","title":"Mass"},{"location":"reference/parsers_sdf/#material","text":"Material ( self )","title":"Material"},{"location":"reference/parsers_sdf/#max","text":"Max ( self , default = 0 )","title":"Max"},{"location":"reference/parsers_sdf/#maxangle","text":"MaxAngle ( self , default = 0 )","title":"MaxAngle"},{"location":"reference/parsers_sdf/#maxcontacts","text":"MaxContacts ( self , default = 20 )","title":"MaxContacts"},{"location":"reference/parsers_sdf/#maxdist","text":"MaxDist ( self , default = 0 )","title":"MaxDist"},{"location":"reference/parsers_sdf/#maxstepsize","text":"MaxStepSize ( self , default = 0.001 )","title":"MaxStepSize"},{"location":"reference/parsers_sdf/#maxtransientvelocity","text":"MaxTransientVelocity ( self , default = 0.01 )","title":"MaxTransientVelocity"},{"location":"reference/parsers_sdf/#maxvel","text":"MaxVel ( self , default = 0.01 )","title":"MaxVel"},{"location":"reference/parsers_sdf/#mean_1","text":"Mean ( self )","title":"Mean"},{"location":"reference/parsers_sdf/#meansize","text":"MeanSize ( self , default = 0 )","title":"MeanSize"},{"location":"reference/parsers_sdf/#measuredirection","text":"MeasureDirection ( self , default = 'child_to_parent' )","title":"MeasureDirection"},{"location":"reference/parsers_sdf/#mesh","text":"Mesh ( self )","title":"Mesh"},{"location":"reference/parsers_sdf/#min","text":"Min ( self , default = 0 )","title":"Min"},{"location":"reference/parsers_sdf/#minangle","text":"MinAngle ( self , default = 0 )","title":"MinAngle"},{"location":"reference/parsers_sdf/#mindepth","text":"MinDepth ( self , default = 0 )","title":"MinDepth"},{"location":"reference/parsers_sdf/#mindist","text":"MinDist ( self , default = 0 )","title":"MinDist"},{"location":"reference/parsers_sdf/#minstepsize","text":"MinStepSize ( self , default = 0.0001 )","title":"MinStepSize"},{"location":"reference/parsers_sdf/#model","text":"Model ( self )","title":"Model"},{"location":"reference/parsers_sdf/#mu","text":"Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Mu"},{"location":"reference/parsers_sdf/#mu2","text":"Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Mu2"},{"location":"reference/parsers_sdf/#mustbeloopjoint","text":"MustBeLoopJoint ( self , default = False )","title":"MustBeLoopJoint"},{"location":"reference/parsers_sdf/#name","text":"Name ( self , default = 'none' )","title":"Name"},{"location":"reference/parsers_sdf/#near","text":"Near ( self , default = 0 )","title":"Near"},{"location":"reference/parsers_sdf/#noise","text":"Noise ( self , type = 'none' , use_type_as = 'attribute' )","title":"Noise"},{"location":"reference/parsers_sdf/#normal","text":"Normal ( self )","title":"Normal"},{"location":"reference/parsers_sdf/#normalmap","text":"NormalMap ( self , default = '' )","title":"NormalMap"},{"location":"reference/parsers_sdf/#ode","text":"ODE ( self , mode = 'physics' )","title":"ODE"},{"location":"reference/parsers_sdf/#orientationreferenceframe","text":"OrientationReferenceFrame ( self )","title":"OrientationReferenceFrame"},{"location":"reference/parsers_sdf/#originvisual","text":"OriginVisual ( self , default = True )","title":"OriginVisual"},{"location":"reference/parsers_sdf/#outerangle","text":"OuterAngle ( self , default = 0 )","title":"OuterAngle"},{"location":"reference/parsers_sdf/#output","text":"Output ( self , default = 'depths' )","title":"Output"},{"location":"reference/parsers_sdf/#overrideimpactcapturevelocity","text":"OverrideImpactCaptureVelocity ( self , default = 0.001 )","title":"OverrideImpactCaptureVelocity"},{"location":"reference/parsers_sdf/#overridestictiontransitionvelocity","text":"OverrideStictionTransitionVelocity ( self , default = 0.9 )","title":"OverrideStictionTransitionVelocity"},{"location":"reference/parsers_sdf/#p1","text":"P1 ( self , default = 0 )","title":"P1"},{"location":"reference/parsers_sdf/#p2","text":"P2 ( self , default = 0 )","title":"P2"},{"location":"reference/parsers_sdf/#parent","text":"Parent ( self , default = 'parent' )","title":"Parent"},{"location":"reference/parsers_sdf/#patchradius","text":"PatchRadius ( self , default = 0 )","title":"PatchRadius"},{"location":"reference/parsers_sdf/#path","text":"Path ( self , default = '__default__' )","title":"Path"},{"location":"reference/parsers_sdf/#physics","text":"Physics ( self , mode = 'ode' )","title":"Physics"},{"location":"reference/parsers_sdf/#plane","text":"Plane ( self )","title":"Plane"},{"location":"reference/parsers_sdf/#plasticcoefrestitution","text":"PlasticCoefRestitution ( self , default = 0.5 )","title":"PlasticCoefRestitution"},{"location":"reference/parsers_sdf/#plasticimpactvelocity","text":"PlasticImpactVelocity ( self , default = 0.5 )","title":"PlasticImpactVelocity"},{"location":"reference/parsers_sdf/#plugin","text":"Plugin ( self , default = {})","title":"Plugin"},{"location":"reference/parsers_sdf/#point","text":"Point ( self , vec_length = 2 )","title":"Point"},{"location":"reference/parsers_sdf/#poissonsratio","text":"PoissonsRatio ( self , default = 0.3 )","title":"PoissonsRatio"},{"location":"reference/parsers_sdf/#polyline","text":"Polyline ( self )","title":"Polyline"},{"location":"reference/parsers_sdf/#pose","text":"Pose ( self )","title":"Pose"},{"location":"reference/parsers_sdf/#preconiters","text":"PreConIters ( self , default = 0 )","title":"PreConIters"},{"location":"reference/parsers_sdf/#precision","text":"Precision ( self )","title":"Precision"},{"location":"reference/parsers_sdf/#providefeedback","text":"ProvideFeedback ( self , default = False )","title":"ProvideFeedback"},{"location":"reference/parsers_sdf/#quadratic","text":"Quadratic ( self , default = 0 )","title":"Quadratic"},{"location":"reference/parsers_sdf/#radius","text":"Radius ( self , default = 0 )","title":"Radius"},{"location":"reference/parsers_sdf/#range","text":"Range ( self )","title":"Range"},{"location":"reference/parsers_sdf/#rate","text":"Rate ( self , type = 'none' )","title":"Rate"},{"location":"reference/parsers_sdf/#ray","text":"Ray ( self )","title":"Ray"},{"location":"reference/parsers_sdf/#realtimefactor","text":"RealTimeFactor ( self , default = 1 )","title":"RealTimeFactor"},{"location":"reference/parsers_sdf/#realtimeupdaterate","text":"RealTimeUpdateRate ( self , default = 1 )","title":"RealTimeUpdateRate"},{"location":"reference/parsers_sdf/#resolution","text":"Resolution ( self , default = 0 )","title":"Resolution"},{"location":"reference/parsers_sdf/#restitutioncoefficient","text":"RestitutionCoefficient ( self , default = 0 )","title":"RestitutionCoefficient"},{"location":"reference/parsers_sdf/#rollingfriction","text":"RollingFriction ( self , default = 1 )","title":"RollingFriction"},{"location":"reference/parsers_sdf/#sdf","text":"SDF ( self , mode = 'world' )","title":"SDF"},{"location":"reference/parsers_sdf/#samples","text":"Samples ( self , default = 640 )","title":"Samples"},{"location":"reference/parsers_sdf/#save","text":"Save ( self )","title":"Save"},{"location":"reference/parsers_sdf/#scale","text":"Scale ( self , size = 3 )","title":"Scale"},{"location":"reference/parsers_sdf/#scan","text":"Scan ( self )","title":"Scan"},{"location":"reference/parsers_sdf/#scene","text":"Scene ( self )","title":"Scene"},{"location":"reference/parsers_sdf/#script","text":"Script ( self , mode = 'material' )","title":"Script"},{"location":"reference/parsers_sdf/#selfcollide","text":"SelfCollide ( self , default = False )","title":"SelfCollide"},{"location":"reference/parsers_sdf/#sensor","text":"Sensor ( self , mode = 'altimeter' )","title":"Sensor"},{"location":"reference/parsers_sdf/#shader","text":"Shader ( self )","title":"Shader"},{"location":"reference/parsers_sdf/#shadows","text":"Shadows ( self , default = True )","title":"Shadows"},{"location":"reference/parsers_sdf/#simbody","text":"Simbody ( self , mode = 'physics' )","title":"Simbody"},{"location":"reference/parsers_sdf/#size","text":"Size ( self , vec_length = 3 )","title":"Size"},{"location":"reference/parsers_sdf/#skin","text":"Skin ( self )","title":"Skin"},{"location":"reference/parsers_sdf/#sky","text":"Sky ( self )","title":"Sky"},{"location":"reference/parsers_sdf/#slip","text":"Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip"},{"location":"reference/parsers_sdf/#slip1","text":"Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip1"},{"location":"reference/parsers_sdf/#slip2","text":"Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip2"},{"location":"reference/parsers_sdf/#softcfm","text":"SoftCFM ( self , default = 0 )","title":"SoftCFM"},{"location":"reference/parsers_sdf/#softerp","text":"SoftERP ( self , default = 0.2 )","title":"SoftERP"},{"location":"reference/parsers_sdf/#solver","text":"Solver ( self , engine = 'ode' )","title":"Solver"},{"location":"reference/parsers_sdf/#sor","text":"Sor ( self , default = 1.3 )","title":"Sor"},{"location":"reference/parsers_sdf/#specular","text":"Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ])","title":"Specular"},{"location":"reference/parsers_sdf/#speed","text":"Speed ( self , default = 0.6 )","title":"Speed"},{"location":"reference/parsers_sdf/#sphere","text":"Sphere ( self )","title":"Sphere"},{"location":"reference/parsers_sdf/#splitimpulse","text":"SplitImpulse ( self , default = True )","title":"SplitImpulse"},{"location":"reference/parsers_sdf/#splitimpulsepenetrationthreshold","text":"SplitImpulsePenetrationThreshold ( self , default =- 0.01 )","title":"SplitImpulsePenetrationThreshold"},{"location":"reference/parsers_sdf/#spot","text":"Spot ( self )","title":"Spot"},{"location":"reference/parsers_sdf/#springreference","text":"SpringReference ( self , default = 0 )","title":"SpringReference"},{"location":"reference/parsers_sdf/#springstiffness","text":"SpringStiffness ( self , default = 0 )","title":"SpringStiffness"},{"location":"reference/parsers_sdf/#start","text":"Start ( self , default = 0 )","title":"Start"},{"location":"reference/parsers_sdf/#static","text":"Static ( self , default = False )","title":"Static"},{"location":"reference/parsers_sdf/#staticfriction","text":"StaticFriction ( self , default = 0.9 )","title":"StaticFriction"},{"location":"reference/parsers_sdf/#stddev_1","text":"StdDev ( self )","title":"StdDev"},{"location":"reference/parsers_sdf/#stiffness","text":"Stiffness ( self , default = 100000000.0 )","title":"Stiffness"},{"location":"reference/parsers_sdf/#submesh","text":"SubMesh ( self )","title":"SubMesh"},{"location":"reference/parsers_sdf/#sunrise","text":"Sunrise ( self , default = 0 )","title":"Sunrise"},{"location":"reference/parsers_sdf/#sunset","text":"Sunset ( self , default = 0 )","title":"Sunset"},{"location":"reference/parsers_sdf/#surface","text":"Surface ( self )","title":"Surface"},{"location":"reference/parsers_sdf/#surfaceradius","text":"SurfaceRadius ( self , default = 0 )","title":"SurfaceRadius"},{"location":"reference/parsers_sdf/#threshold","text":"Threshold ( self , default = 0 )","title":"Threshold"},{"location":"reference/parsers_sdf/#time","text":"Time ( self , default = 0 )","title":"Time"},{"location":"reference/parsers_sdf/#topic","text":"Topic ( self , default = 'none' )","title":"Topic"},{"location":"reference/parsers_sdf/#torsional","text":"Torsional ( self )","title":"Torsional"},{"location":"reference/parsers_sdf/#trackvisual","text":"TrackVisual ( self )","title":"TrackVisual"},{"location":"reference/parsers_sdf/#trajectory","text":"Trajectory ( self )","title":"Trajectory"},{"location":"reference/parsers_sdf/#transparency","text":"Transparency ( self , default = 0 )","title":"Transparency"},{"location":"reference/parsers_sdf/#type","text":"Type ( self , default = '' )","title":"Type"},{"location":"reference/parsers_sdf/#urdf","text":"URDF ( self , mode = 'model' )","title":"URDF"},{"location":"reference/parsers_sdf/#uri","text":"URI ( self , default = '' )","title":"URI"},{"location":"reference/parsers_sdf/#updaterate","text":"UpdateRate ( self , default = 0 )","title":"UpdateRate"},{"location":"reference/parsers_sdf/#upper","text":"Upper ( self , default = 1e+16 )","title":"Upper"},{"location":"reference/parsers_sdf/#usedynamicmoirescaling","text":"UseDynamicMOIRescaling ( self , default = False )","title":"UseDynamicMOIRescaling"},{"location":"reference/parsers_sdf/#usemodelframe","text":"UseModelFrame ( self , default = False )","title":"UseModelFrame"},{"location":"reference/parsers_sdf/#useparentmodelframe","text":"UseParentModelFrame ( self , default = False )","title":"UseParentModelFrame"},{"location":"reference/parsers_sdf/#usepatchradius","text":"UsePatchRadius ( self , default = True )","title":"UsePatchRadius"},{"location":"reference/parsers_sdf/#velocity","text":"Velocity ( self , default =- 1 )","title":"Velocity"},{"location":"reference/parsers_sdf/#vertical","text":"Vertical ( self )","title":"Vertical"},{"location":"reference/parsers_sdf/#verticalposition","text":"VerticalPosition ( self )","title":"VerticalPosition"},{"location":"reference/parsers_sdf/#verticalvelocity","text":"VerticalVelocity ( self )","title":"VerticalVelocity"},{"location":"reference/parsers_sdf/#viewcontroller","text":"ViewController ( self , default = 'orbit' )","title":"ViewController"},{"location":"reference/parsers_sdf/#viscousfriction","text":"ViscousFriction ( self , default = 0 )","title":"ViscousFriction"},{"location":"reference/parsers_sdf/#visual","text":"Visual ( self )","title":"Visual"},{"location":"reference/parsers_sdf/#visualize","text":"Visualize ( self , default = False )","title":"Visualize"},{"location":"reference/parsers_sdf/#waypoint","text":"Waypoint ( self )","title":"Waypoint"},{"location":"reference/parsers_sdf/#width","text":"Width ( self , default = 320 )","title":"Width"},{"location":"reference/parsers_sdf/#world","text":"World ( self )","title":"World"},{"location":"reference/parsers_sdf/#x","text":"X ( self )","title":"X"},{"location":"reference/parsers_sdf/#xyz","text":"XYZ ( self , default = [ 0 , 0 , 1 ])","title":"XYZ"},{"location":"reference/parsers_sdf/#y","text":"Y ( self )","title":"Y"},{"location":"reference/parsers_sdf/#z","text":"Z ( self )","title":"Z"},{"location":"reference/parsers_sdf_config/","text":"pcg_gazebo.parsers.sdf_config \u00b6 Author \u00b6 Author ( self ) Description \u00b6 Description ( self , default = 'none' ) EMail \u00b6 EMail ( self , default = 'none' ) Model \u00b6 Model ( self ) Name \u00b6 Name ( self , default = 'none' ) SDF \u00b6 SDF ( self , default = 'model.sdf' ) Version \u00b6 Version ( self , default = 'none' )","title":"pcg_gazebo.parsers.sdf_config"},{"location":"reference/parsers_sdf_config/#pcg_gazeboparserssdf_config","text":"","title":"pcg_gazebo.parsers.sdf_config"},{"location":"reference/parsers_sdf_config/#author","text":"Author ( self )","title":"Author"},{"location":"reference/parsers_sdf_config/#description","text":"Description ( self , default = 'none' )","title":"Description"},{"location":"reference/parsers_sdf_config/#email","text":"EMail ( self , default = 'none' )","title":"EMail"},{"location":"reference/parsers_sdf_config/#model","text":"Model ( self )","title":"Model"},{"location":"reference/parsers_sdf_config/#name","text":"Name ( self , default = 'none' )","title":"Name"},{"location":"reference/parsers_sdf_config/#sdf","text":"SDF ( self , default = 'model.sdf' )","title":"SDF"},{"location":"reference/parsers_sdf_config/#version","text":"Version ( self , default = 'none' )","title":"Version"},{"location":"reference/parsers_types/","text":"pcg_gazebo.parsers.types \u00b6 XMLBase \u00b6 XMLBase ( self , min_value = None , max_value = None ) attributes \u00b6 dict : XML properties xml_element_name \u00b6 str : Name of the SDF element xml_format \u00b6 str : Name of the XML format XMLBoolean \u00b6 XMLBoolean ( self , default = False ) XMLCustom \u00b6 XMLCustom ( self , default = {}) XMLInteger \u00b6 XMLInteger ( self , default = 0 , min_value = None , max_value = None ) XMLScalar \u00b6 XMLScalar ( self , default = 0 , min_value = None , max_value = None ) XMLString \u00b6 XMLString ( self , default = '' ) XMLVector \u00b6 XMLVector ( self , size = None , min_value = None , max_value = None )","title":"pcg_gazebo.parsers.types"},{"location":"reference/parsers_types/#pcg_gazeboparserstypes","text":"","title":"pcg_gazebo.parsers.types"},{"location":"reference/parsers_types/#xmlbase","text":"XMLBase ( self , min_value = None , max_value = None )","title":"XMLBase"},{"location":"reference/parsers_types/#attributes","text":"dict : XML properties","title":"attributes"},{"location":"reference/parsers_types/#xml_element_name","text":"str : Name of the SDF element","title":"xml_element_name"},{"location":"reference/parsers_types/#xml_format","text":"str : Name of the XML format","title":"xml_format"},{"location":"reference/parsers_types/#xmlboolean","text":"XMLBoolean ( self , default = False )","title":"XMLBoolean"},{"location":"reference/parsers_types/#xmlcustom","text":"XMLCustom ( self , default = {})","title":"XMLCustom"},{"location":"reference/parsers_types/#xmlinteger","text":"XMLInteger ( self , default = 0 , min_value = None , max_value = None )","title":"XMLInteger"},{"location":"reference/parsers_types/#xmlscalar","text":"XMLScalar ( self , default = 0 , min_value = None , max_value = None )","title":"XMLScalar"},{"location":"reference/parsers_types/#xmlstring","text":"XMLString ( self , default = '' )","title":"XMLString"},{"location":"reference/parsers_types/#xmlvector","text":"XMLVector ( self , size = None , min_value = None , max_value = None )","title":"XMLVector"},{"location":"reference/parsers_urdf/","text":"pcg_gazebo.parsers.urdf \u00b6 get_all_urdf_element_classes \u00b6 get_all_urdf_element_classes () Get list of all URDF element classes. create_urdf_element \u00b6 create_urdf_element ( tag , * args ) URDF element factory. Input arguments tag ( type: str ): Name of the URDF element. args : Extra arguments for URDF element constructor. Returns URDF element if tag refers to a valid URDF element. None , otherwise. create_urdf_type \u00b6 create_urdf_type ( tag ) Return handle of the URDF element type. Input arguments tag ( type: str ): Name of the URDF element. Returns URDF element type if tag is valid, None otherwise`. is_urdf_element \u00b6 is_urdf_element ( obj ) Test if XML element is an URDF element. Actuator \u00b6 Actuator ( self ) Axis \u00b6 Axis ( self , default = [ 1 , 0 , 0 ]) Box \u00b6 Box ( self ) Child \u00b6 Child ( self , default = 'link' ) Collision \u00b6 Collision ( self ) Color \u00b6 Color ( self , default = [ 0 , 0 , 0 , 1 ]) Cylinder \u00b6 Cylinder ( self ) Dynamics \u00b6 Dynamics ( self ) Gazebo \u00b6 Gazebo ( self , mode = 'none' , sdf_elements = {}) Geometry \u00b6 Geometry ( self ) HardwareInterface \u00b6 HardwareInterface ( self , default = 'EffortJointInterface' ) Inertia \u00b6 Inertia ( self ) Inertial \u00b6 Inertial ( self ) Joint \u00b6 Joint ( self ) Limit \u00b6 Limit ( self ) Link \u00b6 Link ( self ) Mass \u00b6 Mass ( self ) Material \u00b6 Material ( self , mode = 'color' ) MechanicalReduction \u00b6 MechanicalReduction ( self , default = 1 ) Mesh \u00b6 Mesh ( self ) Mimic \u00b6 Mimic ( self ) Origin \u00b6 Origin ( self ) Parent \u00b6 Parent ( self , default = 'link' ) Robot \u00b6 Robot ( self ) SafetyController \u00b6 SafetyController ( self ) Sphere \u00b6 Sphere ( self ) Texture \u00b6 Texture ( self , default = 'filename' ) Transmission \u00b6 Transmission ( self ) Type \u00b6 Type ( self , default = 'transmission_interface/SimpleTransmission' ) Visual \u00b6 Visual ( self )","title":"pcg_gazebo.parsers.urdf"},{"location":"reference/parsers_urdf/#pcg_gazeboparsersurdf","text":"","title":"pcg_gazebo.parsers.urdf"},{"location":"reference/parsers_urdf/#get_all_urdf_element_classes","text":"get_all_urdf_element_classes () Get list of all URDF element classes.","title":"get_all_urdf_element_classes"},{"location":"reference/parsers_urdf/#create_urdf_element","text":"create_urdf_element ( tag , * args ) URDF element factory. Input arguments tag ( type: str ): Name of the URDF element. args : Extra arguments for URDF element constructor. Returns URDF element if tag refers to a valid URDF element. None , otherwise.","title":"create_urdf_element"},{"location":"reference/parsers_urdf/#create_urdf_type","text":"create_urdf_type ( tag ) Return handle of the URDF element type. Input arguments tag ( type: str ): Name of the URDF element. Returns URDF element type if tag is valid, None otherwise`.","title":"create_urdf_type"},{"location":"reference/parsers_urdf/#is_urdf_element","text":"is_urdf_element ( obj ) Test if XML element is an URDF element.","title":"is_urdf_element"},{"location":"reference/parsers_urdf/#actuator","text":"Actuator ( self )","title":"Actuator"},{"location":"reference/parsers_urdf/#axis","text":"Axis ( self , default = [ 1 , 0 , 0 ])","title":"Axis"},{"location":"reference/parsers_urdf/#box","text":"Box ( self )","title":"Box"},{"location":"reference/parsers_urdf/#child","text":"Child ( self , default = 'link' )","title":"Child"},{"location":"reference/parsers_urdf/#collision","text":"Collision ( self )","title":"Collision"},{"location":"reference/parsers_urdf/#color","text":"Color ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Color"},{"location":"reference/parsers_urdf/#cylinder","text":"Cylinder ( self )","title":"Cylinder"},{"location":"reference/parsers_urdf/#dynamics","text":"Dynamics ( self )","title":"Dynamics"},{"location":"reference/parsers_urdf/#gazebo","text":"Gazebo ( self , mode = 'none' , sdf_elements = {})","title":"Gazebo"},{"location":"reference/parsers_urdf/#geometry","text":"Geometry ( self )","title":"Geometry"},{"location":"reference/parsers_urdf/#hardwareinterface","text":"HardwareInterface ( self , default = 'EffortJointInterface' )","title":"HardwareInterface"},{"location":"reference/parsers_urdf/#inertia","text":"Inertia ( self )","title":"Inertia"},{"location":"reference/parsers_urdf/#inertial","text":"Inertial ( self )","title":"Inertial"},{"location":"reference/parsers_urdf/#joint","text":"Joint ( self )","title":"Joint"},{"location":"reference/parsers_urdf/#limit","text":"Limit ( self )","title":"Limit"},{"location":"reference/parsers_urdf/#link","text":"Link ( self )","title":"Link"},{"location":"reference/parsers_urdf/#mass","text":"Mass ( self )","title":"Mass"},{"location":"reference/parsers_urdf/#material","text":"Material ( self , mode = 'color' )","title":"Material"},{"location":"reference/parsers_urdf/#mechanicalreduction","text":"MechanicalReduction ( self , default = 1 )","title":"MechanicalReduction"},{"location":"reference/parsers_urdf/#mesh","text":"Mesh ( self )","title":"Mesh"},{"location":"reference/parsers_urdf/#mimic","text":"Mimic ( self )","title":"Mimic"},{"location":"reference/parsers_urdf/#origin","text":"Origin ( self )","title":"Origin"},{"location":"reference/parsers_urdf/#parent","text":"Parent ( self , default = 'link' )","title":"Parent"},{"location":"reference/parsers_urdf/#robot","text":"Robot ( self )","title":"Robot"},{"location":"reference/parsers_urdf/#safetycontroller","text":"SafetyController ( self )","title":"SafetyController"},{"location":"reference/parsers_urdf/#sphere","text":"Sphere ( self )","title":"Sphere"},{"location":"reference/parsers_urdf/#texture","text":"Texture ( self , default = 'filename' )","title":"Texture"},{"location":"reference/parsers_urdf/#transmission","text":"Transmission ( self )","title":"Transmission"},{"location":"reference/parsers_urdf/#type","text":"Type ( self , default = 'transmission_interface/SimpleTransmission' )","title":"Type"},{"location":"reference/parsers_urdf/#visual","text":"Visual ( self )","title":"Visual"},{"location":"reference/path/","text":"pcg_gazebo.path \u00b6 Path \u00b6 Path ( self , uri ) Path resolver for ROS and Gazebo model paths. The paths can be resolved if provided as: Absolute path $(find ros_pkg) package:// model:// file:// Input arguments uri ( type: str ): Input path to be resolved. is_valid \u00b6 bool : True if the absolute URI exists. original_uri \u00b6 str : Original URI provided.","title":"pcg_gazebo.path"},{"location":"reference/path/#pcg_gazebopath","text":"","title":"pcg_gazebo.path"},{"location":"reference/path/#path","text":"Path ( self , uri ) Path resolver for ROS and Gazebo model paths. The paths can be resolved if provided as: Absolute path $(find ros_pkg) package:// model:// file:// Input arguments uri ( type: str ): Input path to be resolved.","title":"Path"},{"location":"reference/path/#is_valid","text":"bool : True if the absolute URI exists.","title":"is_valid"},{"location":"reference/path/#original_uri","text":"str : Original URI provided.","title":"original_uri"},{"location":"reference/simulation/","text":"pcg_gazebo.simulation \u00b6 Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo. create_object \u00b6 create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance. get_gazebo_model_folders \u00b6 get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names. load_gazebo_models \u00b6 load_gazebo_models () Search for Gazebo models in the local .gazebo/models folder and in the ROS paths. Returns dict : Information of all Gazebo models found get_gazebo_models \u00b6 get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo/models folder and in the catkin workspace as a dictionary. get_gazebo_model_names \u00b6 get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo/models folders and catkin workspace. get_gazebo_model_ros_pkg \u00b6 get_gazebo_model_ros_pkg ( name ) Return name of the ROS package where the Gazebo model is located, None if it was found in .gazebo/models. is_gazebo_model \u00b6 is_gazebo_model ( name , include_custom_paths = False ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model. get_gazebo_model_path \u00b6 get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder get_gazebo_model_sdf \u00b6 get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model.sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo.parsers.types.XMLBase instance as an SDF element. Box \u00b6 Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo.simulation.Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [1, 1, 1] ): Vector with width, length and height of the box, collision \u00b6 pcg_gazebo.simulation.properties.Collision : Return single box-shaped collision model. size \u00b6 List of float : Size of the box as [width, length, height] visual \u00b6 pcg_gazebo.simulation.properties.Visual : Return single box-shaped visual model. to_sdf \u00b6 Box . to_sdf ( type = 'model' , name = 'box' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. add_inertial \u00b6 Box . add_inertial ( mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_inertial \u00b6 Box . update_inertial ( mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Box . update_collision () Update collision model according to the current size . update_visual \u00b6 Box . update_visual () Update visual model according to the current size . Cylinder \u00b6 Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters. collision \u00b6 pcg_gazebo.simulation.properties.Collision : Return single cylinder-shaped collision model. length \u00b6 float : Length of the cylinder in meters radius \u00b6 float : Radius of the cylinder in meters visual \u00b6 pcg_gazebo.simulation.properties.Visual : Return single cylinder-shaped visual model. to_sdf \u00b6 Cylinder . to_sdf ( type = 'model' , name = 'cylinder' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. update_inertial \u00b6 Cylinder . update_inertial ( mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Cylinder . update_collision () Update collision model according to the current length and radius . update_visual \u00b6 Cylinder . update_visual () Update visual model according to the current length and radius . Joint \u00b6 Joint ( self , name = 'joint' , parent = None , child = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 , use_parent_model_frame = False ) Light \u00b6 Light ( self , name = 'default' , type = 'point' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , inner_angle = None , outer_angle = None , falloff = None ) Link \u00b6 Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , gravity = True , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ). collisions \u00b6 List of pcg_gazebo.simulation.properties.Collision : List of collision models creation_time \u00b6 float : Time of creation of this object, if it represents a single-link model. gravity \u00b6 bool : Flag to that link is affected by gravity inertial \u00b6 pcg_gazebo.simulation.properties.Inertial : Description of the object's moments of inertia. kinematic \u00b6 bool : Flag to indicate if the model is purely kinematic life_timeout \u00b6 float : Life timeout timestamp for this object, if it represents a single-link model self_collide \u00b6 bool : Self-collision flag static \u00b6 bool : Flag to indicate if object is static visuals \u00b6 List of pcg_gazebo.simulation.properties.Visual : List of visual models create_link_from_mesh \u00b6 Link . create_link_from_mesh ( name = 'link' , visual_mesh = None , collision_mesh = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' , visual_parameters = {}, collision_parameters = {}) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the visual mesh file or a mesh object. collision_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [0, 0, 0, 0, 0, 0] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict(ixx=0, iyy=0, izz=0, ixy=0, ixz=0, iyz=0) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo.simulation.Link instance. enable_collision \u00b6 Link . enable_collision () Enable the inclusion of the collision models in the exported SDF description. disable_collision \u00b6 Link . disable_collision () Disable the inclusion of the collision models in the exported SDF description. enable_visual \u00b6 Link . enable_visual () Enable the inclusion of the visual models in the exported SDF description. disable_visual \u00b6 Link . disable_visual () Disable the inclusion of the collision models in the exported SDF description. get_collision_by_name \u00b6 Link . get_collision_by_name ( name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo.simulation.properties.Collision , or None if not collision with the given name is found. has_collision \u00b6 Link . has_collision ( name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise. get_visual_by_name \u00b6 Link . get_visual_by_name ( name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo.simulation.properties.Visual , or None if not visual with the given name is found. has_visual \u00b6 Link . has_visual ( name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise. add_empty_visual \u00b6 Link . add_empty_visual ( name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists. add_visual \u00b6 Link . add_visual ( visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo.simulation.properties.Visual ): Visual element Returns bool : True , if visual element could be added to object. add_empty_collision \u00b6 Link . add_empty_collision ( name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists. add_collision \u00b6 Link . add_collision ( collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo.simulation.properties.Collision ): Collision element Returns bool : True , if collision element could be added to object. to_sdf \u00b6 Link . to_sdf ( type = 'link' , name = 'model' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. from_sdf \u00b6 Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo.simulation.Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.Link ): SDF object Returns pcg_gazebo.simulation.Link : Simulation object instance export_to_gazebo_model \u00b6 Link . export_to_gazebo_model ( output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir/ model.sdf model.config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1.6 ): Version of the SDF format version ( type: str , default: 0.1.0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully. add_inertial \u00b6 Link . add_inertial ( mass ) This function must be implemented by derived classes. update_inertial \u00b6 Link . update_inertial () This function must be implemented by derived classes. update_collision \u00b6 Link . update_collision () This function must be implemented by derived classes. update_visual \u00b6 Link . update_visual () This function must be implemented by derived classes. add_sensor \u00b6 Link . add_sensor ( name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo.simulation.sensors.Sensor ): Sensor description Returns bool : True , if sensor could be added to link. to_markers \u00b6 Link . to_markers () Generate visualization_msgs/Marker instances from the visual and/or collision entities. Returns visualization_msgs/MarkerArray get_footprint \u00b6 Link . get_footprint ( mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon get_meshes \u00b6 Link . get_meshes ( mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes. get_bounds \u00b6 Link . get_bounds ( mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds ModelGroup \u00b6 ModelGroup ( self , name = 'group' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], is_ground_plane = False ) lights \u00b6 dict : Lights models \u00b6 dict : Models n_lights \u00b6 int : Number of lights n_models \u00b6 int : Number of models reset_models \u00b6 ModelGroup . reset_models () Reset the list of models. add_model \u00b6 ModelGroup . add_model ( tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model \u00b6 ModelGroup . rm_model ( tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists \u00b6 ModelGroup . model_exists ( tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_include \u00b6 ModelGroup . add_include ( include ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_light \u00b6 ModelGroup . add_light ( tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description rm_light \u00b6 ModelGroup . rm_light ( tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists \u00b6 ModelGroup . light_exists ( tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. Plane \u00b6 Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ]) Polyline \u00b6 Polyline ( self , name = 'polyline' , height = 1 , points = []) SimulationModel \u00b6 SimulationModel ( self , name = 'model' , parent = 'world' , is_ground_plane = False , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Sphere \u00b6 Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters collision \u00b6 pcg_gazebo.simulation.properties.Collision : Return single sphere-shaped collision model. radius \u00b6 float : Radius of the sphere in meters visual \u00b6 pcg_gazebo.simulation.properties.Visual : Return single sphere-shaped visual model. to_sdf \u00b6 Sphere . to_sdf ( type = 'model' , name = 'sphere' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance. add_inertial \u00b6 Sphere . add_inertial ( mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one update_inertial \u00b6 Sphere . update_inertial ( mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Sphere . update_collision () Update collision model according to the current radius . update_visual \u00b6 Sphere . update_visual () Update visual model according to the current radius . World \u00b6 World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [0, 0, -9.8] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody . engine \u00b6 str : Name identifier of the physics engine gravity \u00b6 list : Acceleration of gravity vector lights \u00b6 dict : Lights model_groups \u00b6 dict : Model groups models \u00b6 dict : Models physics \u00b6 pcg_gazebo.simulation.physics.Physics : Physics engine instance reset_physics \u00b6 World . reset_physics ( engine = 'ode' , * args , ** kwargs ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody . reset_models \u00b6 World . reset_models () Reset the list of models. add_include \u00b6 World . add_include ( include , group = 'default' ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_model \u00b6 World . add_model ( tag , model , group = 'default' ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model \u00b6 World . rm_model ( tag , group = 'default' ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists \u00b6 World . model_exists ( tag , group = None ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_plugin \u00b6 World . add_plugin ( tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo.parsers.sdf.Plugin or pcg_gazebo.simulation.properties.Plugin ): Plugin description. rm_plugin \u00b6 World . rm_plugin ( tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world. plugin_exists \u00b6 World . plugin_exists ( tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise. add_light \u00b6 World . add_light ( tag , light , group = 'default' ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description rm_light \u00b6 World . rm_light ( tag , group = 'default' ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists \u00b6 World . light_exists ( tag , group = 'default' ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. to_sdf \u00b6 World . to_sdf ( type = 'world' , with_default_ground_plane = False , with_default_sun = False , sdf_version = '1.6' ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo.parsers.sdf.SDF with a world element in it or pcg_gazebo.parsers.sdf.World . from_sdf \u00b6 World . from_sdf ( sdf ) Parse an pcg_gazebo.parsers.sdf.World into a World class. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.World ): SDF world element Returns pcg_gazebo.parsers.sdf.World instance. create_scene \u00b6 World . create_scene ( mesh_type = 'collision' , add_pseudo_color = True , ignore_models = None , add_axis = True ) Return a trimesh.Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color. plot_footprints \u00b6 World . plot_footprints ( fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 , ground_plane_models = None ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib.pyplot.Figure or bokeh.plotting.Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib.pyplot.Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0.5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib.pyplot.Figure or bokeh.plotting.Figure . export_to_file \u00b6 World . export_to_file ( output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True , models_output_dir = None , overwrite = True , sdf_version = '1.6' ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str","title":"pcg_gazebo.simulation"},{"location":"reference/simulation/#pcg_gazebosimulation","text":"Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo.","title":"pcg_gazebo.simulation"},{"location":"reference/simulation/#create_object","text":"create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance.","title":"create_object"},{"location":"reference/simulation/#get_gazebo_model_folders","text":"get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names.","title":"get_gazebo_model_folders"},{"location":"reference/simulation/#load_gazebo_models","text":"load_gazebo_models () Search for Gazebo models in the local .gazebo/models folder and in the ROS paths. Returns dict : Information of all Gazebo models found","title":"load_gazebo_models"},{"location":"reference/simulation/#get_gazebo_models","text":"get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo/models folder and in the catkin workspace as a dictionary.","title":"get_gazebo_models"},{"location":"reference/simulation/#get_gazebo_model_names","text":"get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo/models folders and catkin workspace.","title":"get_gazebo_model_names"},{"location":"reference/simulation/#get_gazebo_model_ros_pkg","text":"get_gazebo_model_ros_pkg ( name ) Return name of the ROS package where the Gazebo model is located, None if it was found in .gazebo/models.","title":"get_gazebo_model_ros_pkg"},{"location":"reference/simulation/#is_gazebo_model","text":"is_gazebo_model ( name , include_custom_paths = False ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model.","title":"is_gazebo_model"},{"location":"reference/simulation/#get_gazebo_model_path","text":"get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder","title":"get_gazebo_model_path"},{"location":"reference/simulation/#get_gazebo_model_sdf","text":"get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model.sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo.parsers.types.XMLBase instance as an SDF element.","title":"get_gazebo_model_sdf"},{"location":"reference/simulation/#box","text":"Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo.simulation.Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [1, 1, 1] ): Vector with width, length and height of the box,","title":"Box"},{"location":"reference/simulation/#collision","text":"pcg_gazebo.simulation.properties.Collision : Return single box-shaped collision model.","title":"collision"},{"location":"reference/simulation/#size","text":"List of float : Size of the box as [width, length, height]","title":"size"},{"location":"reference/simulation/#visual","text":"pcg_gazebo.simulation.properties.Visual : Return single box-shaped visual model.","title":"visual"},{"location":"reference/simulation/#to_sdf","text":"Box . to_sdf ( type = 'model' , name = 'box' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#add_inertial","text":"Box . add_inertial ( mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms","title":"add_inertial"},{"location":"reference/simulation/#update_inertial","text":"Box . update_inertial ( mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"reference/simulation/#update_collision","text":"Box . update_collision () Update collision model according to the current size .","title":"update_collision"},{"location":"reference/simulation/#update_visual","text":"Box . update_visual () Update visual model according to the current size .","title":"update_visual"},{"location":"reference/simulation/#cylinder","text":"Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters.","title":"Cylinder"},{"location":"reference/simulation/#collision_1","text":"pcg_gazebo.simulation.properties.Collision : Return single cylinder-shaped collision model.","title":"collision"},{"location":"reference/simulation/#length","text":"float : Length of the cylinder in meters","title":"length"},{"location":"reference/simulation/#radius","text":"float : Radius of the cylinder in meters","title":"radius"},{"location":"reference/simulation/#visual_1","text":"pcg_gazebo.simulation.properties.Visual : Return single cylinder-shaped visual model.","title":"visual"},{"location":"reference/simulation/#to_sdf_1","text":"Cylinder . to_sdf ( type = 'model' , name = 'cylinder' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#update_inertial_1","text":"Cylinder . update_inertial ( mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"reference/simulation/#update_collision_1","text":"Cylinder . update_collision () Update collision model according to the current length and radius .","title":"update_collision"},{"location":"reference/simulation/#update_visual_1","text":"Cylinder . update_visual () Update visual model according to the current length and radius .","title":"update_visual"},{"location":"reference/simulation/#joint","text":"Joint ( self , name = 'joint' , parent = None , child = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 , use_parent_model_frame = False )","title":"Joint"},{"location":"reference/simulation/#light","text":"Light ( self , name = 'default' , type = 'point' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , inner_angle = None , outer_angle = None , falloff = None )","title":"Light"},{"location":"reference/simulation/#link","text":"Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , gravity = True , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ).","title":"Link"},{"location":"reference/simulation/#collisions","text":"List of pcg_gazebo.simulation.properties.Collision : List of collision models","title":"collisions"},{"location":"reference/simulation/#creation_time","text":"float : Time of creation of this object, if it represents a single-link model.","title":"creation_time"},{"location":"reference/simulation/#gravity","text":"bool : Flag to that link is affected by gravity","title":"gravity"},{"location":"reference/simulation/#inertial","text":"pcg_gazebo.simulation.properties.Inertial : Description of the object's moments of inertia.","title":"inertial"},{"location":"reference/simulation/#kinematic","text":"bool : Flag to indicate if the model is purely kinematic","title":"kinematic"},{"location":"reference/simulation/#life_timeout","text":"float : Life timeout timestamp for this object, if it represents a single-link model","title":"life_timeout"},{"location":"reference/simulation/#self_collide","text":"bool : Self-collision flag","title":"self_collide"},{"location":"reference/simulation/#static","text":"bool : Flag to indicate if object is static","title":"static"},{"location":"reference/simulation/#visuals","text":"List of pcg_gazebo.simulation.properties.Visual : List of visual models","title":"visuals"},{"location":"reference/simulation/#create_link_from_mesh","text":"Link . create_link_from_mesh ( name = 'link' , visual_mesh = None , collision_mesh = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' , visual_parameters = {}, collision_parameters = {}) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the visual mesh file or a mesh object. collision_mesh ( type: str or trimesh.Trimesh , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [1, 1, 1] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [0, 0, 0, 0, 0, 0] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict(ixx=0, iyy=0, izz=0, ixy=0, ixz=0, iyz=0) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo.simulation.Link instance.","title":"create_link_from_mesh"},{"location":"reference/simulation/#enable_collision","text":"Link . enable_collision () Enable the inclusion of the collision models in the exported SDF description.","title":"enable_collision"},{"location":"reference/simulation/#disable_collision","text":"Link . disable_collision () Disable the inclusion of the collision models in the exported SDF description.","title":"disable_collision"},{"location":"reference/simulation/#enable_visual","text":"Link . enable_visual () Enable the inclusion of the visual models in the exported SDF description.","title":"enable_visual"},{"location":"reference/simulation/#disable_visual","text":"Link . disable_visual () Disable the inclusion of the collision models in the exported SDF description.","title":"disable_visual"},{"location":"reference/simulation/#get_collision_by_name","text":"Link . get_collision_by_name ( name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo.simulation.properties.Collision , or None if not collision with the given name is found.","title":"get_collision_by_name"},{"location":"reference/simulation/#has_collision","text":"Link . has_collision ( name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise.","title":"has_collision"},{"location":"reference/simulation/#get_visual_by_name","text":"Link . get_visual_by_name ( name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo.simulation.properties.Visual , or None if not visual with the given name is found.","title":"get_visual_by_name"},{"location":"reference/simulation/#has_visual","text":"Link . has_visual ( name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise.","title":"has_visual"},{"location":"reference/simulation/#add_empty_visual","text":"Link . add_empty_visual ( name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists.","title":"add_empty_visual"},{"location":"reference/simulation/#add_visual","text":"Link . add_visual ( visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo.simulation.properties.Visual ): Visual element Returns bool : True , if visual element could be added to object.","title":"add_visual"},{"location":"reference/simulation/#add_empty_collision","text":"Link . add_empty_collision ( name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists.","title":"add_empty_collision"},{"location":"reference/simulation/#add_collision","text":"Link . add_collision ( collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo.simulation.properties.Collision ): Collision element Returns bool : True , if collision element could be added to object.","title":"add_collision"},{"location":"reference/simulation/#to_sdf_2","text":"Link . to_sdf ( type = 'link' , name = 'model' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#from_sdf","text":"Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo.simulation.Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.Link ): SDF object Returns pcg_gazebo.simulation.Link : Simulation object instance","title":"from_sdf"},{"location":"reference/simulation/#export_to_gazebo_model","text":"Link . export_to_gazebo_model ( output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir/ model.sdf model.config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1.6 ): Version of the SDF format version ( type: str , default: 0.1.0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully.","title":"export_to_gazebo_model"},{"location":"reference/simulation/#add_inertial_1","text":"Link . add_inertial ( mass ) This function must be implemented by derived classes.","title":"add_inertial"},{"location":"reference/simulation/#update_inertial_2","text":"Link . update_inertial () This function must be implemented by derived classes.","title":"update_inertial"},{"location":"reference/simulation/#update_collision_2","text":"Link . update_collision () This function must be implemented by derived classes.","title":"update_collision"},{"location":"reference/simulation/#update_visual_2","text":"Link . update_visual () This function must be implemented by derived classes.","title":"update_visual"},{"location":"reference/simulation/#add_sensor","text":"Link . add_sensor ( name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo.simulation.sensors.Sensor ): Sensor description Returns bool : True , if sensor could be added to link.","title":"add_sensor"},{"location":"reference/simulation/#to_markers","text":"Link . to_markers () Generate visualization_msgs/Marker instances from the visual and/or collision entities. Returns visualization_msgs/MarkerArray","title":"to_markers"},{"location":"reference/simulation/#get_footprint","text":"Link . get_footprint ( mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely._GEOMETRIES.Polygon or shapely._GEOMETRIES.MultiPolygon","title":"get_footprint"},{"location":"reference/simulation/#get_meshes","text":"Link . get_meshes ( mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes.","title":"get_meshes"},{"location":"reference/simulation/#get_bounds","text":"Link . get_bounds ( mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds","title":"get_bounds"},{"location":"reference/simulation/#modelgroup","text":"ModelGroup ( self , name = 'group' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], is_ground_plane = False )","title":"ModelGroup"},{"location":"reference/simulation/#lights","text":"dict : Lights","title":"lights"},{"location":"reference/simulation/#models","text":"dict : Models","title":"models"},{"location":"reference/simulation/#n_lights","text":"int : Number of lights","title":"n_lights"},{"location":"reference/simulation/#n_models","text":"int : Number of models","title":"n_models"},{"location":"reference/simulation/#reset_models","text":"ModelGroup . reset_models () Reset the list of models.","title":"reset_models"},{"location":"reference/simulation/#add_model","text":"ModelGroup . add_model ( tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world.","title":"add_model"},{"location":"reference/simulation/#rm_model","text":"ModelGroup . rm_model ( tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world.","title":"rm_model"},{"location":"reference/simulation/#model_exists","text":"ModelGroup . model_exists ( tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise.","title":"model_exists"},{"location":"reference/simulation/#add_include","text":"ModelGroup . add_include ( include ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world.","title":"add_include"},{"location":"reference/simulation/#add_light","text":"ModelGroup . add_light ( tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description","title":"add_light"},{"location":"reference/simulation/#rm_light","text":"ModelGroup . rm_light ( tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world.","title":"rm_light"},{"location":"reference/simulation/#light_exists","text":"ModelGroup . light_exists ( tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise.","title":"light_exists"},{"location":"reference/simulation/#plane","text":"Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ])","title":"Plane"},{"location":"reference/simulation/#polyline","text":"Polyline ( self , name = 'polyline' , height = 1 , points = [])","title":"Polyline"},{"location":"reference/simulation/#simulationmodel","text":"SimulationModel ( self , name = 'model' , parent = 'world' , is_ground_plane = False , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"SimulationModel"},{"location":"reference/simulation/#sphere","text":"Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo.simulation.Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters","title":"Sphere"},{"location":"reference/simulation/#collision_2","text":"pcg_gazebo.simulation.properties.Collision : Return single sphere-shaped collision model.","title":"collision"},{"location":"reference/simulation/#radius_1","text":"float : Radius of the sphere in meters","title":"radius"},{"location":"reference/simulation/#visual_2","text":"pcg_gazebo.simulation.properties.Visual : Return single sphere-shaped visual model.","title":"visual"},{"location":"reference/simulation/#to_sdf_3","text":"Sphere . to_sdf ( type = 'model' , name = 'sphere' , sdf_version = '1.6' , resource_prefix = '' , model_folder = None , copy_resources = False ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1.6 ): Version of the output SDF element Returns pcg_gazebo.parsers.types.XMLBase : SDF element instance.","title":"to_sdf"},{"location":"reference/simulation/#add_inertial_2","text":"Sphere . add_inertial ( mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one","title":"add_inertial"},{"location":"reference/simulation/#update_inertial_3","text":"Sphere . update_inertial ( mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"reference/simulation/#update_collision_3","text":"Sphere . update_collision () Update collision model according to the current radius .","title":"update_collision"},{"location":"reference/simulation/#update_visual_3","text":"Sphere . update_visual () Update visual model according to the current radius .","title":"update_visual"},{"location":"reference/simulation/#world","text":"World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [0, 0, -9.8] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody .","title":"World"},{"location":"reference/simulation/#engine","text":"str : Name identifier of the physics engine","title":"engine"},{"location":"reference/simulation/#gravity_1","text":"list : Acceleration of gravity vector","title":"gravity"},{"location":"reference/simulation/#lights_1","text":"dict : Lights","title":"lights"},{"location":"reference/simulation/#model_groups","text":"dict : Model groups","title":"model_groups"},{"location":"reference/simulation/#models_1","text":"dict : Models","title":"models"},{"location":"reference/simulation/#physics","text":"pcg_gazebo.simulation.physics.Physics : Physics engine instance","title":"physics"},{"location":"reference/simulation/#reset_physics","text":"World . reset_physics ( engine = 'ode' , * args , ** kwargs ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody .","title":"reset_physics"},{"location":"reference/simulation/#reset_models_1","text":"World . reset_models () Reset the list of models.","title":"reset_models"},{"location":"reference/simulation/#add_include_1","text":"World . add_include ( include , group = 'default' ) Add a model via include method. Input arguments include ( type: pcg_gazebo.parsers.sdf.Include ): SDF <include> element Returns bool : True , if model directed by the include element could be parsed and added to the world.","title":"add_include"},{"location":"reference/simulation/#add_model_1","text":"World . add_model ( tag , model , group = 'default' ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo.simulation.SimulationModel ): Model object Returns bool : True , if model could be added to the world.","title":"add_model"},{"location":"reference/simulation/#rm_model_1","text":"World . rm_model ( tag , group = 'default' ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world.","title":"rm_model"},{"location":"reference/simulation/#model_exists_1","text":"World . model_exists ( tag , group = None ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise.","title":"model_exists"},{"location":"reference/simulation/#add_plugin","text":"World . add_plugin ( tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo.parsers.sdf.Plugin or pcg_gazebo.simulation.properties.Plugin ): Plugin description.","title":"add_plugin"},{"location":"reference/simulation/#rm_plugin","text":"World . rm_plugin ( tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world.","title":"rm_plugin"},{"location":"reference/simulation/#plugin_exists","text":"World . plugin_exists ( tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise.","title":"plugin_exists"},{"location":"reference/simulation/#add_light_1","text":"World . add_light ( tag , light , group = 'default' ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo.parsers.sdf.Light or pcg_gazebo.simulation.properties.Light ): Light description","title":"add_light"},{"location":"reference/simulation/#rm_light_1","text":"World . rm_light ( tag , group = 'default' ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world.","title":"rm_light"},{"location":"reference/simulation/#light_exists_1","text":"World . light_exists ( tag , group = 'default' ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise.","title":"light_exists"},{"location":"reference/simulation/#to_sdf_4","text":"World . to_sdf ( type = 'world' , with_default_ground_plane = False , with_default_sun = False , sdf_version = '1.6' ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo.parsers.sdf.SDF with a world element in it or pcg_gazebo.parsers.sdf.World .","title":"to_sdf"},{"location":"reference/simulation/#from_sdf_1","text":"World . from_sdf ( sdf ) Parse an pcg_gazebo.parsers.sdf.World into a World class. Input arguments sdf ( type: pcg_gazebo.parsers.sdf.World ): SDF world element Returns pcg_gazebo.parsers.sdf.World instance.","title":"from_sdf"},{"location":"reference/simulation/#create_scene","text":"World . create_scene ( mesh_type = 'collision' , add_pseudo_color = True , ignore_models = None , add_axis = True ) Return a trimesh.Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color.","title":"create_scene"},{"location":"reference/simulation/#plot_footprints","text":"World . plot_footprints ( fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 , ground_plane_models = None ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib.pyplot.Figure or bokeh.plotting.Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib.pyplot.Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0.5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib.pyplot.Figure or bokeh.plotting.Figure .","title":"plot_footprints"},{"location":"reference/simulation/#export_to_file","text":"World . export_to_file ( output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True , models_output_dir = None , overwrite = True , sdf_version = '1.6' ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str","title":"export_to_file"},{"location":"reference/simulation_physics/","text":"pcg_gazebo.simulation.physics \u00b6 Bullet \u00b6 Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = 10 _ , split_impulse_penetration_threshold = 11 __ ) ODE \u00b6 ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_rescaling = False , friction_model = 10 ____________ , cfm = 11 , erp = 12 , contact_surface_layer = 13 __ , contact_max_correcting_vel = 14 ) Physics \u00b6 Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False ) Simbody \u00b6 Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 10 , static_friction = 11 , dynamic_friction = 12 , viscous_friction = 13 , override_impact_capture_velocity = 14 __ , override_stiction_transition_velocity = 15 __ )","title":"pcg_gazebo.simulation.physics"},{"location":"reference/simulation_physics/#pcg_gazebosimulationphysics","text":"","title":"pcg_gazebo.simulation.physics"},{"location":"reference/simulation_physics/#bullet","text":"Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = 10 _ , split_impulse_penetration_threshold = 11 __ )","title":"Bullet"},{"location":"reference/simulation_physics/#ode","text":"ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_rescaling = False , friction_model = 10 ____________ , cfm = 11 , erp = 12 , contact_surface_layer = 13 __ , contact_max_correcting_vel = 14 )","title":"ODE"},{"location":"reference/simulation_physics/#physics","text":"Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False )","title":"Physics"},{"location":"reference/simulation_physics/#simbody","text":"Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 10 , static_friction = 11 , dynamic_friction = 12 , viscous_friction = 13 , override_impact_capture_velocity = 14 __ , override_stiction_transition_velocity = 15 __ )","title":"Simbody"},{"location":"reference/simulation_properties/","text":"pcg_gazebo.simulation.properties \u00b6 Axis \u00b6 Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit =- 1 , effort_limit =- 1 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , use_parent_model_frame = False ) BoundingBox \u00b6 BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ]) Collision \u00b6 Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = None , mu2 = None , friction = None , friction2 = None , slip1 = None , slip2 = None , rolling_friction = None , fdir1 = None , max_contacts = None , soft_cfm = None , soft_erp = None , kp = None , kd = None , max_vel = None , min_depth = None , split_impulse = None , split_impulse_penetration_threshold = None , restitution_coefficient = None , threshold = None , collide_bitmask = None , collide_without_contact = None , collide_without_contact_bitmask = None , category_bitmask = None , poissons_ratio = None , elastic_modulus = None ) Footprint \u00b6 Footprint ( self ) Geometry \u00b6 Geometry ( self , geo_type = None , ** kwargs ) Inertial \u00b6 Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) Material \u00b6 Material ( self ) Mesh \u00b6 Mesh ( self , filename = None , load_mesh = False ) Noise \u00b6 Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' ) Plugin \u00b6 Plugin ( self , name = None , filename = None ) Pose \u00b6 Pose ( self , pos = None , rot = None ) Visual \u00b6 Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"pcg_gazebo.simulation.properties"},{"location":"reference/simulation_properties/#pcg_gazebosimulationproperties","text":"","title":"pcg_gazebo.simulation.properties"},{"location":"reference/simulation_properties/#axis","text":"Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit =- 1 , effort_limit =- 1 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , use_parent_model_frame = False )","title":"Axis"},{"location":"reference/simulation_properties/#boundingbox","text":"BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ])","title":"BoundingBox"},{"location":"reference/simulation_properties/#collision","text":"Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = None , mu2 = None , friction = None , friction2 = None , slip1 = None , slip2 = None , rolling_friction = None , fdir1 = None , max_contacts = None , soft_cfm = None , soft_erp = None , kp = None , kd = None , max_vel = None , min_depth = None , split_impulse = None , split_impulse_penetration_threshold = None , restitution_coefficient = None , threshold = None , collide_bitmask = None , collide_without_contact = None , collide_without_contact_bitmask = None , category_bitmask = None , poissons_ratio = None , elastic_modulus = None )","title":"Collision"},{"location":"reference/simulation_properties/#footprint","text":"Footprint ( self )","title":"Footprint"},{"location":"reference/simulation_properties/#geometry","text":"Geometry ( self , geo_type = None , ** kwargs )","title":"Geometry"},{"location":"reference/simulation_properties/#inertial","text":"Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 )","title":"Inertial"},{"location":"reference/simulation_properties/#material","text":"Material ( self )","title":"Material"},{"location":"reference/simulation_properties/#mesh","text":"Mesh ( self , filename = None , load_mesh = False )","title":"Mesh"},{"location":"reference/simulation_properties/#noise","text":"Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' )","title":"Noise"},{"location":"reference/simulation_properties/#plugin","text":"Plugin ( self , name = None , filename = None )","title":"Plugin"},{"location":"reference/simulation_properties/#pose","text":"Pose ( self , pos = None , rot = None )","title":"Pose"},{"location":"reference/simulation_properties/#visual","text":"Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"Visual"},{"location":"reference/simulation_sensors/","text":"pcg_gazebo.simulation.sensors \u00b6 Camera \u00b6 Camera ( self , name = 'camera' , type = 'camera' , camera_name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ]) Contact \u00b6 Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' ) IMU \u00b6 IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Ray \u00b6 Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 ) Sensor \u00b6 Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) pose \u00b6 pcg_gazebo.simulation.properties.Pose : Pose of the object","title":"pcg_gazebo.simulation.sensors"},{"location":"reference/simulation_sensors/#pcg_gazebosimulationsensors","text":"","title":"pcg_gazebo.simulation.sensors"},{"location":"reference/simulation_sensors/#camera","text":"Camera ( self , name = 'camera' , type = 'camera' , camera_name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ])","title":"Camera"},{"location":"reference/simulation_sensors/#contact","text":"Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' )","title":"Contact"},{"location":"reference/simulation_sensors/#imu","text":"IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"IMU"},{"location":"reference/simulation_sensors/#ray","text":"Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 )","title":"Ray"},{"location":"reference/simulation_sensors/#sensor","text":"Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"Sensor"},{"location":"reference/simulation_sensors/#pose","text":"pcg_gazebo.simulation.properties.Pose : Pose of the object","title":"pose"},{"location":"reference/task_manager/","text":"pcg_gazebo.task_manager \u00b6 This module holds all entities related to task scheduling and stages. is_roscore_running \u00b6 is_roscore_running ( ros_master_uri = 'http://localhost:11311' ) Return True if a roscore is running for the provided ROS URI Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target roscore node to be tested is_gazebo_running \u00b6 is_gazebo_running ( ros_master_uri = 'http://localhost:11311' ) Return True if an instance of Gazebo is running and was initialized are a ROS node. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rosparam_list \u00b6 get_rosparam_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS parameter names in the parameter server running under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rostopic_list \u00b6 get_rostopic_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS topic names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested get_rosservice_list \u00b6 get_rosservice_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS service names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested GazeboProxy \u00b6 GazeboProxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) ProcessManager \u00b6 ProcessManager ( self , label = 'default' , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , output_log_dir = None ) ROSConfig \u00b6 ROSConfig ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 ) Server \u00b6 Server ( self ) SimulationTimer \u00b6 SimulationTimer ( self , simulation_timeout = 0 , start_gazebo_timeout = 60 , ros_config = None , output_log_dir = None , callback = None ) Stage \u00b6 Stage ( self , name ) Task \u00b6 Task ( self , task_name , command , params , config , has_gazebo = False , type = None , required = False , process_timeout = None , task_killed_callback = None , stage = None , output_log_dir = None , simulation_timeout = None )","title":"pcg_gazebo.task_manager"},{"location":"reference/task_manager/#pcg_gazebotask_manager","text":"This module holds all entities related to task scheduling and stages.","title":"pcg_gazebo.task_manager"},{"location":"reference/task_manager/#is_roscore_running","text":"is_roscore_running ( ros_master_uri = 'http://localhost:11311' ) Return True if a roscore is running for the provided ROS URI Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target roscore node to be tested","title":"is_roscore_running"},{"location":"reference/task_manager/#is_gazebo_running","text":"is_gazebo_running ( ros_master_uri = 'http://localhost:11311' ) Return True if an instance of Gazebo is running and was initialized are a ROS node. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"is_gazebo_running"},{"location":"reference/task_manager/#get_rosparam_list","text":"get_rosparam_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS parameter names in the parameter server running under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"get_rosparam_list"},{"location":"reference/task_manager/#get_rostopic_list","text":"get_rostopic_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS topic names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"get_rostopic_list"},{"location":"reference/task_manager/#get_rosservice_list","text":"get_rosservice_list ( ros_master_uri = 'http://localhost:11311' ) Return the list of ROS service names under the provided URI. If no roscore is running, return None instead. Input parameters ros_master_uri ( type: str , default: ( http://localhost:11311 )): The ROS URI of the target node to be tested","title":"get_rosservice_list"},{"location":"reference/task_manager/#gazeboproxy","text":"GazeboProxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None )","title":"GazeboProxy"},{"location":"reference/task_manager/#processmanager","text":"ProcessManager ( self , label = 'default' , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , output_log_dir = None )","title":"ProcessManager"},{"location":"reference/task_manager/#rosconfig","text":"ROSConfig ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 )","title":"ROSConfig"},{"location":"reference/task_manager/#server","text":"Server ( self )","title":"Server"},{"location":"reference/task_manager/#simulationtimer","text":"SimulationTimer ( self , simulation_timeout = 0 , start_gazebo_timeout = 60 , ros_config = None , output_log_dir = None , callback = None )","title":"SimulationTimer"},{"location":"reference/task_manager/#stage","text":"Stage ( self , name )","title":"Stage"},{"location":"reference/task_manager/#task","text":"Task ( self , task_name , command , params , config , has_gazebo = False , type = None , required = False , process_timeout = None , task_killed_callback = None , stage = None , output_log_dir = None , simulation_timeout = None )","title":"Task"},{"location":"reference/visualization/","text":"pcg_gazebo.visualization \u00b6","title":"pcg_gazebo.visualization"},{"location":"reference/visualization/#pcg_gazebovisualization","text":"","title":"pcg_gazebo.visualization"}]}